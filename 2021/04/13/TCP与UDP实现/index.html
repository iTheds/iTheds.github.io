<!DOCTYPE html>
<html lang="en">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="iTheds">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="iTheds">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="TCP与UDP实现发送管道和接收管道。 疑问 一个端口是否可以接收多个套接字并发送数据？  服务端监听一个端口的时候，如果收到了 TCP 连接，还可以继续调用 Accept 进行监听。服务端接收到之后会分配一个端口用以进行通信。此时，服务端和客户端相当于只是占用了一个可知的端口，就是服务端用于监听连接请求的端口。客户端和服务端的通信端口是使用的分配的端口？？？这种通信方式和指定绑定端口进行通信有差">
<meta property="og:type" content="article">
<meta property="og:title" content="TCP与UDP实现">
<meta property="og:url" content="http://itheds.github.io/2021/04/13/TCP%E4%B8%8EUDP%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="TCP与UDP实现发送管道和接收管道。 疑问 一个端口是否可以接收多个套接字并发送数据？  服务端监听一个端口的时候，如果收到了 TCP 连接，还可以继续调用 Accept 进行监听。服务端接收到之后会分配一个端口用以进行通信。此时，服务端和客户端相当于只是占用了一个可知的端口，就是服务端用于监听连接请求的端口。客户端和服务端的通信端口是使用的分配的端口？？？这种通信方式和指定绑定端口进行通信有差">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-12T16:00:00.000Z">
<meta property="article:modified_time" content="2024-07-09T02:30:29.094Z">
<meta property="article:author" content="iTheds">
<meta property="article:tag" content="Socket网络编程">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
    <title>TCP与UDP实现 · iTheds&#39;s Studio</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20211217" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20211217" as="style">
    <link rel="stylesheet" href="/css/dark.css">
    <link rel="stylesheet" href="/css/mobile.css?v=20211217" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20211217" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20211217" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 6.3.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>iTheds's Studio.</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">iTheds&#39;s Studio.</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">TCP与UDP实现</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
    
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                TCP与UDP实现
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
                    
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
    
        <a class="post-tag" href="javascript:void(0);" data-tags="Socket网络编程">Socket网络编程</a>
    
</div>

                
                <!-- 文章字数统计 -->
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2021/04/13</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h1 id="TCP与UDP实现"><a href="#TCP与UDP实现" class="headerlink" title="TCP与UDP实现"></a>TCP与UDP实现</h1><p>发送管道和接收管道。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><ol>
<li>一个端口是否可以接收多个套接字并发送数据？</li>
</ol>
<p>服务端监听一个端口的时候，如果收到了 TCP 连接，还可以继续调用 Accept 进行监听。服务端接收到之后会分配一个端口用以进行通信。<br>此时，服务端和客户端相当于只是占用了一个可知的端口，就是服务端用于监听连接请求的端口。客户端和服务端的通信端口是使用的分配的端口？？？<br>这种通信方式和指定绑定端口进行通信有差别吗？？？</p>
<p>理论上理解：按上述方式，服务端只使用了一个端口进行通信，但是维持了多个 socket ，包括用于监听的 socket。客户端使用的端口是建立连接之后系统分配的端口。这些通信的 socket 性能不会受太大的影响。</p>
<p>所以如果可以的话，约定一定的协议，服务端只需要开启一个端口，就可以给 m 个客户端，发送不同的数据。<br>甚至支持对于”第二层协议”的支持，那么就可以对协议进行解析，并且使用该协议进行通信。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ol>
<li>阻塞情况下的测试</li>
<li>大数据传输测试</li>
<li>接口攻击.</li>
</ol>
<h2 id="TCP方式"><a href="#TCP方式" class="headerlink" title="TCP方式"></a>TCP方式</h2><p>请求连接时需要三次握手。<br>结束时需要四次挥手。</p>
<p>TCP是可靠的连接,协议里已经处理了丢包&#x2F;误包重发的机制。</p>
<p>服务端初始化之后，bind一个自己的addr，设置为listen，阻塞到accept。accept接收到数据之后返回一个socket，此时已经建立了TCP可靠连接，使用该socket可以send到地址。</p>
<p>客户端，connect到服务端所bind的套接字，超时后继续connect，此过程发送SYN J请求连接，之后接收服务端返回的确认SYN K和ACK J+1包，connect将ACK K+1包返回，之后即可开始recv()阻塞等待接收数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 服务端</span><br><span class="line">    participant 客户端</span><br><span class="line">    loop accept , connect</span><br><span class="line">    客户端--&gt;&gt;服务端: SYN J</span><br><span class="line">    end</span><br><span class="line">    服务端--&gt;&gt;+客户端: SYN K, ACK J+1</span><br><span class="line">    客户端--&gt;&gt;-服务端: ACK K+1</span><br></pre></td></tr></table></figure>

<p>首先设置版本和lib库</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//socket 需要</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">WORD socketVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(socketVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Init socket dll error!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client:主动连接并接收数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WSADATA wsaData;</span><br><span class="line">WORD socketVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(socketVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Init socket dll error!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;<span class="comment">//发送套接字</span></span><br><span class="line">SOCKET sockfd = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> port = <span class="number">9999</span>;</span><br><span class="line"><span class="type">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Error socket\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nSendBuf = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(sockfd , SOL_SOCKET , SO_SNDBUF , (<span class="type">const</span> <span class="type">char</span>*) &amp;nSendBuf, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//套接字，连接到指定ip端口</span></span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">address.sin_addr.s_addr = <span class="built_in">inet_addr</span>(ip);</span><br><span class="line"></span><br><span class="line">ret = ::<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line"><span class="keyword">while</span> (ret == <span class="number">-1</span> &amp;&amp; swi == <span class="number">1</span>) &#123;</span><br><span class="line">	ret = ::<span class="built_in">connect</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;;i++) &#123;</span><br><span class="line">	ret = <span class="built_in">recv</span>(sockfd, buffer, <span class="number">1024</span>, <span class="number">0</span>);<span class="comment">//阻塞点</span></span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error recv\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span> , buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server:监听连接并发送数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">CommunicationThread</span><span class="params">(LPVOID args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	WSADATA wsaData;</span><br><span class="line">	WORD socketVersion = <span class="built_in">MAKEWORD</span>(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">WSAStartup</span>(socketVersion, &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Init socket dll error!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;<span class="comment">//发送套接字</span></span><br><span class="line">	SOCKET sockfd = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> port = <span class="number">9999</span>;</span><br><span class="line">	<span class="type">char</span> ip[<span class="number">16</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">	<span class="keyword">if</span> (sockfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error socket\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> nSendBuf = <span class="number">1024</span>;</span><br><span class="line">	<span class="built_in">setsockopt</span>(sockfd, SOL_SOCKET, SO_SNDBUF, (<span class="type">const</span> <span class="type">char</span>*)&amp;nSendBuf, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定端口套接字</span></span><br><span class="line">	sockaddr_in InetAddr;</span><br><span class="line">	InetAddr.sin_family = AF_INET;</span><br><span class="line">	InetAddr.sin_addr.s_addr = INADDR_ANY;<span class="comment">//IP问题</span></span><br><span class="line">	InetAddr.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//绑定端口</span></span><br><span class="line">	ret = <span class="built_in">bind</span>(sockfd, (SOCKADDR*)&amp;InetAddr, <span class="built_in">sizeof</span>(InetAddr));</span><br><span class="line">	<span class="keyword">if</span> (SOCKET_ERROR == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error bind\n&quot;</span>);</span><br><span class="line">		<span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">listen</span>(sockfd, <span class="number">5</span>);</span><br><span class="line">	<span class="keyword">if</span> (SOCKET_ERROR == ret)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error listen\n&quot;</span>);</span><br><span class="line">		::<span class="built_in">closesocket</span>(sockfd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//监听</span></span><br><span class="line">	SOCKET hClient = <span class="number">0</span>;</span><br><span class="line">	SOCKADDR_IN localAddr;</span><br><span class="line">	<span class="type">int</span> iaddrSize = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line">	hClient = <span class="built_in">accept</span>(sockfd, (<span class="keyword">struct</span> sockaddr*)&amp;localAddr, &amp;iaddrSize);<span class="comment">//阻塞</span></span><br><span class="line">	<span class="keyword">if</span> (INVALID_SOCKET == hClient) &#123;</span><br><span class="line">		<span class="comment">//fail</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Error accept\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; ;i++) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span> , <span class="number">1024</span>);</span><br><span class="line">		<span class="built_in">memcpy</span>( buffer, &amp;i, <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">strcat</span>(buffer, <span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">send</span>(hClient, (<span class="type">char</span>*)buffer, <span class="built_in">strlen</span>(buffer), <span class="number">0</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Error send\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s \n&quot;</span>, buffer);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="UDP方式"><a href="#UDP方式" class="headerlink" title="UDP方式"></a>UDP方式</h2><p>UDP实际上是最简单的IP协议通信方式，除了少量的差错控制等，与IP协议没有差别。<br>同时UDP也可以实现可靠传输，如果按照此法实现，则对比于 TCP 不需要受拥塞控制的影响，主动降低传输速率。<br>有两种逻辑方式。</p>
<ol>
<li>服务端知道客户端、多个客户端的地址IP和端口，那么不需要做任何事，直接sendto套接字地址addr即可。<br> 客户端需要bind自身IP和端口，recvfrom接收即可，此时recvfrom不需要记录源的地址信息。</li>
<li>服务端不知道客户端的地址，但是客户端知道服务端的地址。服务端bind自身地址之后，recvfrom阻塞等待。接收到客户端的第一个信息之后，recvfrom保存返回的address，之后使用该套接字地址进行sendto发送。<br> 客户端需要类似请求的方式进行发送sendto到服务端所bind的套接字地址，之后recvfrom即可。此方法可以使用心跳的间歇性sendto的方式进行连接。</li>
</ol>
<h2 id="最大传输单元-MTU"><a href="#最大传输单元-MTU" class="headerlink" title="最大传输单元 MTU"></a>最大传输单元 MTU</h2><p>首先要搞清楚，分片和分包的区别：</p>
<ul>
<li>分片（Fragmentation）：这是指在网络层将一个大的数据包分成多个较小的数据包，以适应底层网络的最大传输单元（ MTU ）。分片通常由 IP 协议处理。</li>
<li>分包（Segmentation）：这是指在传输层将较大的数据块分成多个较小的部分，以便更容易进行传输和处理。分包通常由 TCP 协议处理。</li>
</ul>
<p>然后是网路层次：</p>
<table>
<thead>
<tr>
<th align="center">层次</th>
<th align="left">层名称</th>
<th align="left">功能描述</th>
<th align="left">示例协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">7</td>
<td align="left">应用层</td>
<td align="left">提供网络服务给应用程序，如HTTP、FTP、SMTP。</td>
<td align="left">HTTP, FTP, SMTP, DNS, Telnet</td>
</tr>
<tr>
<td align="center">6</td>
<td align="left">表示层</td>
<td align="left">数据格式化、加密、解密、压缩。</td>
<td align="left">SSL, TLS, JPEG, ASCII</td>
</tr>
<tr>
<td align="center">5</td>
<td align="left">会话层</td>
<td align="left">建立、管理、终止会话。</td>
<td align="left">PPTP, NetBIOS</td>
</tr>
<tr>
<td align="center">4</td>
<td align="left">传输层</td>
<td align="left">端到端传输、错误检测与纠正（如TCP、UDP）。</td>
<td align="left">TCP, UDP</td>
</tr>
<tr>
<td align="center">3</td>
<td align="left">网络层</td>
<td align="left">路由选择、逻辑地址寻址（如IP）。</td>
<td align="left">IP, ICMP, IGMP, OSPF, EIGRP</td>
</tr>
<tr>
<td align="center">2</td>
<td align="left">数据链路层</td>
<td align="left">链路建立、维护与断开、物理地址寻址（如MAC）。</td>
<td align="left">Ethernet, PPP, Wi-Fi, SLIP, CSLIP, MTU</td>
</tr>
<tr>
<td align="center">1</td>
<td align="left">物理层</td>
<td align="left">比特流传输、物理媒介连接。</td>
<td align="left">RJ45, 802.11, USB</td>
</tr>
</tbody></table>
<p>以太网(Ethernet)数据帧的长度必须在<code>46-1500</code>字节之间，这是由以太网的物理特性决定的。这个1500字节被称为链路层的<code>MTU(最大传输单元)</code>。因特网协议允许<code>IP分片</code>，这样就可以将数据包分成足够小的片段以通过那些最大传输单元小于该数据包原始大小的链路了。这一分片过程发生在网络层，它使用的是将分组发送到链路上的网络接口的最大传输单元的值。这个最大传输单元的值就是MTU（Maximum Transmission Unit）。它是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。<br>即MTU（Maximum Transmission Unit）为1500；</p>
<p>在网络层，因为IP包的首部要占用 0字节，所以这的 MTU为 1500－20＝1480；<br>在传输层，对于UDP包的首部要占用 8字节，所以这的 MTU为 1480－8＝1472；<br>所以，在应用层， Data 最大长度为 1472 。</p>
<h2 id="组包拆包的必要性"><a href="#组包拆包的必要性" class="headerlink" title="组包拆包的必要性"></a>组包拆包的必要性</h2><p>拆包：</p>
<ol>
<li>要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</li>
<li>待发送数据大于MSS(最大报文长度)，TCP在传输前将进行拆包。</li>
</ol>
<p>TCP底层已经完成了拆包的工作。一个包大小默认为 64*1024。</p>
<h2 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h2><p>粘包：</p>
<ol>
<li>发送端多次发送数据，服务端如果没有及时接收将无法判断是否为同一个数据包。</li>
<li>接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li>
</ol>
<p>如果数据没有及时读取，那么将出现取数据时一次取多个包的情况。<br>这就是粘包。</p>
<p>其实要处理粘包问题，要么就取定长，或者通过读取协议进行判断。<br>这个是上层完成的内容。<br>read 和 write 读取的长度内容就是可以控制的地方。</p>
<p>在流传输中出现，UDP不会出现粘包，因为它有消息边界(参考Windows 网络编程)</p>
<h2 id="分包问题"><a href="#分包问题" class="headerlink" title="分包问题"></a>分包问题</h2><p>从三次握手可得知的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Client</span><br><span class="line">    participant Server</span><br><span class="line"></span><br><span class="line">    Client -&gt;&gt; Server: SYN</span><br><span class="line">    Server --&gt;&gt; Client: SYN-ACK</span><br><span class="line">    Client -&gt;&gt; Server: ACK</span><br></pre></td></tr></table></figure>

<p>基于停等协议(Stop-and-wait Protocol)：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Sender</span><br><span class="line">    participant Receiver</span><br><span class="line"></span><br><span class="line">    Sender -&gt;&gt; Receiver: Frame 0</span><br><span class="line">    alt ACK received</span><br><span class="line">        Receiver --&gt;&gt; Sender: ACK 0</span><br><span class="line">        Sender -&gt;&gt; Receiver: Frame 1</span><br><span class="line">        alt ACK received</span><br><span class="line">            Receiver --&gt;&gt; Sender: ACK 1</span><br><span class="line">            Sender -&gt;&gt; Receiver: Frame 2</span><br><span class="line">        else Timeout</span><br><span class="line">            Sender -&gt;&gt; Receiver: Frame 1 (retransmit)</span><br><span class="line">        end</span><br><span class="line">    else Timeout</span><br><span class="line">        Sender -&gt;&gt; Receiver: Frame 0 (retransmit)</span><br><span class="line">    end</span><br></pre></td></tr></table></figure>

<h2 id="阻塞模式"><a href="#阻塞模式" class="headerlink" title="阻塞模式"></a>阻塞模式</h2><p>创建套接字的时候默认时阻塞模式。</p>
<p>connect() 函数其实是阻塞的，因为其寻址过程的原因所以有一个时间长度。确定了连接成功或连接失败才会返回结果。</p>
<p>通过函数 ioctlsocket 设置为非阻塞模式。</p>
<p>非阻塞模式下，connect() 函数将直接返回，但是返回 -1 并非连接错误，调用 select() 函数可以判断 socket 是否可写。</p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>每建立一个套接字，操作系统将分配两个缓冲区，接收缓冲区和发送缓冲区。缓冲区的概念表明，接收数据、发送数据并不受函数 recv() 和 send() 的直接控制，这两个函数实际上是对缓冲区做一个写入和读取数据的操作。一般是 8k ， 可以通过 getsockopt() 获取。通过 setsockopt() 进行设置。</p>
<p>三个地方设置了大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sendto</span>();<span class="comment">//发送数据的大小</span></span><br><span class="line"><span class="built_in">rev</span>();<span class="comment">//接收窗口的大小</span></span><br><span class="line"><span class="built_in">setsockopt</span>(*sockfd, SOL_SOCKET, SO_SNDBUF, (<span class="type">const</span> <span class="type">char</span>*)&amp;nSendBuf, <span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//设置SO_SNDBUF大小</span></span><br></pre></td></tr></table></figure>

<p>send的作用是将数据拷贝进入socket的内核发送缓冲区之中，然后send便会在上层返回。<br>也就是说send()方法返回之时，数据不一定会发送到对端即服务器上去(和write写文件有点类似)，send()仅仅是把应用层buffer的数据拷贝进socket的内核发送buffer中，发送是TCP的事情，和send其实没有太大关系。</p>
<p>接收缓冲区把数据缓存入内核，等待recv()读取，recv()所做的工作，就是把内核缓冲区中的数据拷贝到应用层用户的buffer里面，并返回。若应用进程一直没有调用recv()进行读取的话，此数据会一直缓存在相应socket的接收缓冲区内。对于TCP，如果应用进程一直没有读取，接收缓冲区满了之后，发生的动作是：收端通知发端，接收窗口关闭(win&#x3D;0)。这个便是滑动窗口的实现。保证TCP套接口接收缓冲区不会溢出，从而保证了TCP是可靠传输。因为对方不允许发出超过所通告窗口大小的数据。 这就是TCP的流量控制，如果对方无视窗口大小而发出了超过窗口大小的数据，则接收方TCP将丢弃它。</p>
<p>rev()函数所表达的buf：每次读取的长度。<br>send()可以理解为拷贝的长度，这个长度最好就是数据的长度。<br>setsockopt()所设置的长度是？<br>在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节(异步)；系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中如果发送或是接收的数据量比较大，可以设置socket缓冲区，避免send(),recv()不断的循环收发。SO_RCVBUF接收buffer空间，SO_SNDBUF发送buffer空间。</p>
<h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><p>端口 |<br>ip地址 | INADDR_ANY转换过来就是0.0.0.0，泛指本机的意思</p>
<h2 id="函数工具"><a href="#函数工具" class="headerlink" title="函数工具"></a>函数工具</h2><p>端口和IP信息</p>
<pre><code>#define POST 4567
#define BUFFER_SIZE  1024    //缓冲区大小
</code></pre>
<p>缓冲区的设定</p>
<pre><code>char  receBuf[BUFFER_SIZE]; //发送数据的缓冲区
char  sendBuf[BUFFER_SIZE]; //接受数据的缓冲区
</code></pre>
<p>版本设定：WSADATA，用来设定Winsock动态库支持的最高版本，存储相关信息。</p>
<pre><code>WSADATA WSAData;//用来存储被WSAStartup函数调用后返回的Windows Sockets数据
WSAStartup(MAKEWORD(2,2),&amp;WSAData)==0;//设定版本号
if (WSAStartup(socketVersion, &amp;wsaData) != 0)
&#123;
    //cout &lt;&lt; (&quot;Init socket dll error!&quot;);
    return -1;
&#125;
</code></pre>
<p>初始化套接字，是双向通信的端点的抽象：</p>
<pre><code>SOCKET sock_Client; //用于通信的Socket
</code></pre>
<p>初始化通信套接字，SOCK_DGRAM(数据报套接字&#x2F;无连接的套接字)UDP的Socket.</p>
<pre><code>sock_Client=socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP);//参数3可以指定为0，表示缺省，自动选择是TCP或者UDP。
sock_Client == INVALID_SOCKET//初始化失败条件
</code></pre>
<p>套接字地址</p>
<pre><code>SOCKADDR_IN addr_server; //服务器的地址数据结构
addr_server.sin_family=AF_INET;//IP 地址类型
addr_server.sin_port=htons(POST);//端口号
addr_server.sin_addr.S_un.S_addr=inet_addr(ip);//ip地址 //inet_addr计算机函数，功能是将一个点分十进制的IP转换成一个长整数型数，htonl()函数为新版函数。
</code></pre>
<p>向指定套接字ip发送数据，相对简洁的是send()</p>
<pre><code>sendto(sock_Client,sendBuf,strlen(sendBuf),0,(SOCKADDR*)&amp;addr_server,sizeof(SOCKADDR));
</code></pre>
<p>接收一个数据报并保存源地址到sock，相对简单的是recv()，该套接字socket如果没有设置不阻塞那么该函数将会阻塞。recv将会把接收源的地址存放到sockaddr中。</p>
<pre><code>int last=recvfrom(sock_Client,receBuf,1024,0,(SOCKADDR*)&amp;sock,&amp;len);
</code></pre>
<p>绑定一个套接字地址：使得其他的程序可以通过此套接字地址寻找到该程序。</p>
<pre><code>int ret = bind(Socket, (SOCKADDR*)&amp;InetAddr, sizeof(SOCKADDR));
SOCKET_ERROR == ret//错误代码
</code></pre>
<p>设置该套接字为监听：参数二为队列数量。</p>
<pre><code>ret = listen(socket, 5);//SOCKET_ERROR == ret
</code></pre>
<p>接收一个请求，多用于TCP：接收connect的请求。这两个函数都会阻塞，用于开始三次握手，返回一个套接字socket，可以使用此进行对请求方send()传递数据</p>
<pre><code>hClient = accept(hListenSocket, (struct sockaddr*)&amp;localAddr, &amp;iaddrSize);
</code></pre>
<p>向某个套接字地址请求连接:</p>
<pre><code>ret = ::connect(*sockfd, (struct sockaddr*)&amp;address, sizeof(address));
ret == -1 ;
</code></pre>
<h2 id="如何判断连接断开？"><a href="#如何判断连接断开？" class="headerlink" title="如何判断连接断开？"></a>如何判断连接断开？</h2><ol>
<li>send 空字符返回-1。send空内容会返回0，并且不会在链路种发送任何数据。</li>
<li>对于 send 而言，无论连接是释放还是断开，都会返回 -1。</li>
</ol>
<h2 id="TCP端口一对多还是一对一？"><a href="#TCP端口一对多还是一对一？" class="headerlink" title="TCP端口一对多还是一对一？"></a>TCP端口一对多还是一对一？</h2><p>很奇怪的一件事。<br>首先有两个现象：</p>
<ol>
<li>一个服务器可以响应上万个连接，甚至更多。但是一个服务器可用的端口号上限为65535。</li>
<li>我们默认为一个端口连接一个响应的时候。其他连接也能连接到已经被连接上的端口。</li>
</ol>
<p>经过测试发现，一个TCP端口可以响应不止一个连接。<br>为什么呢，首先，当server accept()阻塞时，并处于监听状态，等待连接。连接成功后我们将保留socket套接字，并且用此进行send通信。同时经过connect()函数 ，client也可以根据定义的socket进行收发。<br>而server的rec()函数进行接收数据时，一直都时通过自己本身定义的socket进行接收的。<br>多个client发送数据也是同一个套接字。</p>
<p>所以一个端口，是可以响应多个连接的。只要保存了响应者的套接字，那么就可以实现在同一个端口发送给多个TCP请求。<br>限制的就是server的TCP recv()窗口大小是有限的。另者就是运行速度了。</p>
<h2 id="监听多个端口"><a href="#监听多个端口" class="headerlink" title="监听多个端口"></a>监听多个端口</h2><p>据资料初步显示，可以使用一些网络模型，socket的I&#x2F;O模型等等。这里提供一个最简单的方法。日后需要学习网络编程，那可以从这个点出发，学习网络模型，最后使用完成端口。</p>
<p><a target="_blank" rel="noopener" href="https://www.jb51.net/article/207159.htm">参考连接</a></p>
<p>实现方法有些曲折，需要一步一步分析；基本的原理就是将socket句柄与事件(event)相关联。Windows有相关的函数可以对多个事件监听，当某个事件被触发，就知道相应的socket有事件到达。可以对该socket做accept，因为已经确定该socket有事件了，所以accept函数会立即返回。这样就达到对多个端口同时监听的目的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">LISTEN_SOCKET_INFO</span></span><br><span class="line">&#123;</span><br><span class="line"> UINT16 listenPort; <span class="comment">//监听端口</span></span><br><span class="line"> SOCKET listenSocket;<span class="comment">//句柄</span></span><br><span class="line"> WSAEVENT netEvent; <span class="comment">//socket对应事件</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">IocpAccept::CreateListenInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//m_listListenPort存储要监听的端口；总个数不超过64个</span></span><br><span class="line"> std::vector&lt;UINT16&gt;::iterator pos = m_listListenPort.<span class="built_in">begin</span>();</span><br><span class="line"> <span class="keyword">for</span> (;pos != m_listListenPort.<span class="built_in">end</span>();++pos)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//生成socket</span></span><br><span class="line">  UINT16 listenPort = *pos;</span><br><span class="line">  LISTEN_SOCKET_INFO socketInfo;</span><br><span class="line">  socketInfo.listenSocket = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  socketInfo.listenPort = listenPort;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定端口</span></span><br><span class="line">  sockaddr_in InetAddr;</span><br><span class="line">  InetAddr.sin_family = AF_INET;</span><br><span class="line">  InetAddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY);</span><br><span class="line">  InetAddr.sin_port = <span class="built_in">htons</span>(listenPort);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> ret = <span class="built_in">bind</span>(socketInfo.listenSocket, (SOCKADDR *)&amp;InetAddr, <span class="built_in">sizeof</span>(InetAddr));</span><br><span class="line">  <span class="keyword">if</span> (SOCKET_ERROR == ret)</span><br><span class="line">  &#123;</span><br><span class="line">   ::<span class="built_in">closesocket</span>(socketInfo.listenSocket);</span><br><span class="line">   <span class="comment">//绑定失败</span></span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//生成事件</span></span><br><span class="line">  socketInfo.netEvent = <span class="built_in">WSACreateEvent</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将socket句柄与事件关联起来。只监视socket的accept和close消息</span></span><br><span class="line">  ret = <span class="built_in">WSAEventSelect</span>(socketInfo.listenSocket, socketInfo.netEvent, FD_ACCEPT | FD_CLOSE);</span><br><span class="line">  <span class="keyword">if</span> (SOCKET_ERROR == ret)</span><br><span class="line">  &#123;</span><br><span class="line">   ::<span class="built_in">closesocket</span>(socketInfo.listenSocket);</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动监听</span></span><br><span class="line">  ret = <span class="built_in">listen</span>(socketInfo.listenSocket, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">if</span> (SOCKET_ERROR == ret)</span><br><span class="line">  &#123;</span><br><span class="line">   ::<span class="built_in">closesocket</span>(socketInfo.listenSocket);</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m_listListenInfo.<span class="built_in">push_back</span>(socketInfo);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>DWORD WSAAPI WSAWaitForMultipleEvents( DWORD cEvents, const WSAEVENT *lphEvents, BOOL fWaitAll, DWORD dwTimeout, BOOL fAlertable );
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成事件地址指针</span></span><br><span class="line"> <span class="type">int</span> nEventTotal;</span><br><span class="line"> WSAEVENT* pEventArray = <span class="built_in">CreateNetEventArray</span>(&amp;nEventTotal);</span><br><span class="line"> <span class="keyword">if</span> (nEventTotal == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">assert</span>(nEventTotal &lt;= WSA_MAXIMUM_WAIT_EVENTS);</span><br><span class="line"></span><br><span class="line"> MSG msg;</span><br><span class="line"> <span class="keyword">while</span> (m_bServerStart)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">// 同时对多个事件做监听</span></span><br><span class="line">  DWORD index = <span class="built_in">WSAWaitForMultipleEvents</span>(nEventTotal,</span><br><span class="line">   pEventArray,</span><br><span class="line">   FALSE,</span><br><span class="line">   <span class="number">10000</span>,</span><br><span class="line">   FALSE);</span><br><span class="line">  <span class="keyword">if</span> (!m_bServerStart)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//查看是哪个事件触发函数返回</span></span><br><span class="line">  index = index - WSA_WAIT_EVENT_0;</span><br><span class="line">  <span class="comment">//客户端连接事件</span></span><br><span class="line">  <span class="keyword">if</span> ((index != WSA_WAIT_FAILED) &amp;&amp; (index != WSA_WAIT_TIMEOUT))</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//pEventArray排序与m_listListenInfo一样，所以可以根据index找到对应的socket。</span></span><br><span class="line">   <span class="comment">//就是该socket导致函数返回</span></span><br><span class="line">   LISTEN_SOCKET_INFO socketInfo = m_listListenInfo[index];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查看具体是什么事件导致函数返回</span></span><br><span class="line">   WSANETWORKEVENTS NetworkEvents;</span><br><span class="line">   <span class="built_in">WSAEnumNetworkEvents</span>(socketInfo.listenSocket, pEventArray[index], &amp;NetworkEvents);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果是accept事件，说明有客户端连接此端口</span></span><br><span class="line">   <span class="keyword">if</span> (NetworkEvents.lNetworkEvents == FD_ACCEPT</span><br><span class="line">    &amp;&amp; NetworkEvents.iErrorCode[FD_ACCEPT_BIT] == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="comment">//这时调用accept函数，会立即返回</span></span><br><span class="line">    <span class="built_in">AcceptListenPort</span>(socketInfo.listenSocket, socketInfo.listenPort);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (NetworkEvents.lNetworkEvents == FD_CLOSE</span><br><span class="line">    &amp;&amp; NetworkEvents.iErrorCode[FD_CLOSE_BIT] == <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//因为超时等其他原因引起函数返回</span></span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">IocpAccept::AcceptListenPort</span><span class="params">(SOCKET hListenSocket, UINT16 nListenPort)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> SOCKET hClient = <span class="number">0</span>;</span><br><span class="line"> SOCKADDR_IN localAddr;</span><br><span class="line"> <span class="type">int</span> iaddrSize = <span class="built_in">sizeof</span>(SOCKADDR_IN);</span><br><span class="line"></span><br><span class="line"> hClient = <span class="built_in">accept</span>(hListenSocket, (<span class="keyword">struct</span> sockaddr *)&amp;localAddr, &amp;iaddrSize);</span><br><span class="line"> <span class="keyword">if</span> (INVALID_SOCKET == hClient)</span><br><span class="line"> &#123;</span><br><span class="line">  <span class="type">int</span> nAccepetError = <span class="built_in">WSAGetLastError</span>();</span><br><span class="line">  <span class="keyword">if</span> (nAccepetError == WSAECONNRESET)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">  <span class="comment">//获取了一个客户端连接</span></span><br><span class="line">  <span class="built_in">OnAcceptClient</span>(hClient, nListenPort);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><p>基本上都是用于解决如何处理 I&#x2F;O 通路中的请求的问题。</p>
<p>一、select模型</p>
<p>使用该模型时，在服务端我们可以开辟两个线程，一个线程用来监听客户端的连接</p>
<p>请求，另一个用来处理客户端的请求。主要用到的函数为select函数。</p>
<p>该模型有个最大的缺点就是，它需要一个死循环不停的去遍历所有的客户端套接字集合，询问是否有数据到来，这样，如果连接的客户端很多，势必会影响处理客户端请求的效率，但它的优点就是解决了每一个客户端都去开辟新的线程与其通信的问题。如果有一个模型，可以不用去轮询客户端套接字集合，而是等待系统通知，当有客户端数据到来时，系统自动的通知我们的程序，这就解决了select模型带来的问题了。</p>
<p>二、WsaAsyncSelect模型</p>
<p>WsaAsyncSelect模型就是这样一个解决了普通select模型问题的socket编程模型。它是在有客户端数据到来时，系统发送消息给我们的程序，我们的程序只要定义好消息的处理方法就可以了，用到的函数只要是WSAAsyncSelect。</p>
<p>可以看到WsaAsyncSelect模型是非常简单的模型，它解决了普通select模型的问题，但是它最大的缺点就是它只能用在windows程序上，因为它需要一个接收系统消息的窗口句柄，那么有没有一个模型既可以解决select模型的问题，又不限定只能是windows程序才能用呢？下面我们来看看WsaEventSelect模型。</p>
<p>三、WsaEventSelect模型</p>
<p>WsaEventSelect模型是一个不用主动去轮询所有客户端套接字是否有数据到来的模型，它也是在客户端有数据到来时，系统发送通知给我们的程序，但是，它不是发送消息，而是通过事件的方式来通知我们的程序，这就解决了WsaAsyncSelect模型只能用在windows程序的问题。</p>
<p>该模型通过一个死循环里面调用WSAWaitForMultipleEvents函数来等待客户端套接字对应的Event的到来，一旦事件通知到达，就通过该套接字去接收数据。虽然WsaEventSelect模型的实现较前两种方法复杂，但它在效率和兼容性方面是最好的。</p>
<p>以上三种模型虽然在效率方面有了不少的提升，但它们都存在一个问题，就是都预设了只能接收64个客户端连接，虽然我们在实现时可以不受这个限制，但是那样，它们所带来的效率提升又将打折扣，那又有没有什么模型可以解决这个问题呢？我们的下一篇重叠I&#x2F;0模型将解决这个问题</p>
<h2 id="socket模型I-x2F-O重叠"><a href="#socket模型I-x2F-O重叠" class="headerlink" title="socket模型I&#x2F;O重叠"></a>socket模型I&#x2F;O重叠</h2><pre><code>typedef struct _WSAOVERLAPPED &#123;

  DWORD Internal;

  DWORD InternalHigh;

  DWORD Offset;

  DWORD OffsetHigh;

  WSAEVENT hEvent;      // 唯一需要关注的参数，用来关联WSAEvent对象
&#125; WSAOVERLAPPED, *LPWSAOVERLAPPED;
</code></pre>
<p>我们需要把WSARecv等操作投递到一个重叠结构上，而我们又需要一个与重叠结构“绑定”在一起的事件对象来通知我们操作的完成，看到了和hEvent参数，不用我说你们也该知<br>道如何来来把事件对象绑定到重叠结构上吧？</p>
<p>WSAEVENT event;                   &#x2F;&#x2F; 定义事件<br>WSAOVERLAPPED AcceptOverlapped ; &#x2F;&#x2F; 定义重叠结构<br>event &#x3D; WSACreateEvent();         &#x2F;&#x2F; 建立一个事件对象句柄<br>ZeroMemory(&amp;AcceptOverlapped, sizeof(WSAOVERLAPPED)); &#x2F;&#x2F; 初始化重叠结构<br>AcceptOverlapped.hEvent &#x3D; event;    &#x2F;&#x2F; Done !！</p>
<h2 id="select模型"><a href="#select模型" class="headerlink" title="select模型"></a>select模型</h2><p>select() 函数和 WSAEventSelec() 函数都声明在 &lt;WinSock2.h&gt; 中。</p>
<h2 id="Overlapped-I-x2F-O-事件通知模型"><a href="#Overlapped-I-x2F-O-事件通知模型" class="headerlink" title="Overlapped I&#x2F;O 事件通知模型"></a>Overlapped I&#x2F;O 事件通知模型</h2><p>比起select、WSAAsyncSelect以及WSAEventSelect等模型，重叠I&#x2F;O（OverlappedI&#x2F;O）模型使应用程序能达到更佳的系统性能。因为使用重叠模型的应用程序通知缓冲区收发系统直接使用数据，也就是说，如果应用程序投递了一个10KB大小的缓冲区来接收数据，且数据已经到达套接字，则该数据将直接被拷贝到投递的缓冲区。而这4种模型种需要调用接收函数之后，数据才从单套接字缓冲区拷贝到应用程序的缓冲区，差别就体现出来了。</p>
<p>1.事件对象通知（event object notification）</p>
<p>2.完成例程（completion routines）</p>
<h2 id="完成端口-IOCP"><a href="#完成端口-IOCP" class="headerlink" title="完成端口 IOCP"></a>完成端口 IOCP</h2><p>IOCP（I&#x2F;O Completion Port，I&#x2F;O完成端口）是性能最好的一种I&#x2F;O模型。它是应用程序使用线程池处理异步I&#x2F;O请求的一种机制。在处理多个并发的异步I&#x2F;O请求时，以往的模型都是在接收请求是创建一个线程来应答请求。这样就有很多的线程并行地运行在系统中。而这些线程都是可运行的，Windows内核花费大量的时间在进行线程的上下文切换，并没有多少时间花在线程运行上。再加上创建新线程的开销比较大，所以造成了效率的低下。</p>
<h3 id="数据结构-OVERLAPPED"><a href="#数据结构-OVERLAPPED" class="headerlink" title="数据结构 OVERLAPPED"></a>数据结构 OVERLAPPED</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_OVERLAPPED</span> &#123;</span><br><span class="line">  ULONG_PTR Internal;</span><br><span class="line">  ULONG_PTR InternalHigh;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      DWORD Offset;</span><br><span class="line">      DWORD OffsetHigh;</span><br><span class="line">    &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    PVOID Pointer;</span><br><span class="line">  &#125; DUMMYUNIONNAME;</span><br><span class="line">  HANDLE    hEvent;</span><br><span class="line">&#125; OVERLAPPED, *LPOVERLAPPED;</span><br></pre></td></tr></table></figure>

<p>Contains information used in asynchronous (or overlapped) input and output (I&#x2F;O).</p>
<p>一个存储着用于异步输入输出(I&#x2F;O)信息的结构体。</p>
<h3 id="CreateIoCompletionPort"><a href="#CreateIoCompletionPort" class="headerlink" title="CreateIoCompletionPort"></a>CreateIoCompletionPort</h3><pre><code>CreateIoCompletionPort((HANDLE)sClient,CompletionPort, (DWORD)PerHandleData, 0);
</code></pre>
<h3 id="GetQueuedCompletionStatus"><a href="#GetQueuedCompletionStatus" class="headerlink" title="GetQueuedCompletionStatus"></a>GetQueuedCompletionStatus</h3><pre><code>GetQueuedCompletionStatus(CompletionPort,&amp;BytesTransferred, (LPDWORD)&amp;PerHandleData,(LPOVERLAPPED*)&amp;PerIoData, INFINITE)
</code></pre>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/baidu_39511645/article/details/78283550">完成端口</a></p>
<h2 id="epoll系统调用、poll、select"><a href="#epoll系统调用、poll、select" class="headerlink" title="epoll系统调用、poll、select"></a>epoll系统调用、poll、select</h2><p>三者是基于linux的系统调用。</p>
<h2 id="windows事件函数"><a href="#windows事件函数" class="headerlink" title="windows事件函数"></a>windows事件函数</h2><h3 id="WSACreateEvent"><a href="#WSACreateEvent" class="headerlink" title="WSACreateEvent()"></a>WSACreateEvent()</h3><p>创建一个事件</p>
<h3 id="WSAWaitForMultipleEvents"><a href="#WSAWaitForMultipleEvents" class="headerlink" title="WSAWaitForMultipleEvents()"></a>WSAWaitForMultipleEvents()</h3><p>对事件链进行监听。接收其消息。</p>
<pre><code>WSAWaitForMultipleEvents( 
DWORD	cEvents,
const 	WSAEVENTFAR * lphEvents, 
BOOL	fWaitAll,
DWORD	dwTimeout,
BOOL	fAlertable );
</code></pre>
<p>cEvents：指出lphEvents所指数组中事件对象句柄的数目。事件对象句柄的最大值为WSA_MAXIMUM_WAIT_EVENTS(64)。<br>lphEvents：指向一个事件对象句柄数组的指针。<br>fWaitAll：指定等待类型。若为真TRUE，则当lphEvents数组中的所有事件对象同时有信号时，函数返回。<br>         若为假FALSE，则当任意一个事件对象有信号时函数即返回。在后一种情况下，返回值指出是哪一个事件对象造成函数返回。<br>dwTimeout：指定超时时间间隔(以毫秒计)。当超时间隔到，函数即返回，不论fWaitAll参数所指定的条件是否满足。<br>          如果dwTimeout为零，则函数测试指定的时间对象的状态，并立即返回。如果dwTimeout是WSA_INFINITE，<br>          则函数的超时间隔永远不会到。	<br>fAlertable：指定当系统将一个输入&#x2F;输出完成例程放入队列以供执行时，函数是否返回。若为真TRUE，则函数返回且执行完成例程。<br>           若为假FALSE，函数不返回，不执行完成例程。请注意在Win16中忽略该参数。<br>返回值<br>如果函数成功，返回值指出造成函数返回的事件对象。</p>
<p>如果函数失败，返回值为WSA_WAIT_FAILED。可调用WSAGetLastError()来获取进一步的错误信息。</p>
<p>错误代码：</p>
<p>WSANOTINITIALISED         在调用本API之前应成功调用WSAStartup()。<br>WSAENETDOWN               网络子系统失效。<br>WSA_NOT_ENOUGH_MEMORY     无足够内存完成该操作。<br>WSA_INVALID_HANDLE        lphEvents数组中的一个或多个值不是合法的事件对象句柄。			<br>WSA_INVALID_PARAMETER     cEvents参数未包含合法的句柄数目。</p>
<p>简述：只要指定事件对象中的一个或全部处于有信号状态，或者超时间隔到，则返回。</p>
<h3 id="WSAEnumNetworkEvents"><a href="#WSAEnumNetworkEvents" class="headerlink" title="WSAEnumNetworkEvents()"></a>WSAEnumNetworkEvents()</h3><p>WSAEnumNetworkEvents()是一种检测所指定的套接口上网络事件发生的命令。<br>简述：检测所指定的套接口上网络事件的发生。</p>
<pre><code>int WSAAPI WSAEnumNetworkEvents ( SOCKET s,
WSAEVENT hEventObject, LPWSANETWORKEVENTS
lpNetworkEvents, LPINT lpiCount);
</code></pre>
<p>s：标识套接口的描述字。<br>hEventObject：(可选)句柄，用于标识需要复位的相应事件对象。<br>lpNetworkEvents：一个WSANETWORKEVENTS结构的数组，每一个元素记录了一个网络事件和相应的错误代码。<br>lpiCount：数组中的元素数目。在返回时，本参数表示数组中的实际元素数目；如果返回值是WSAENOBUFS，则表示为获取所有网络事件所需的元素数目。<br>返回值：<br>如果操作成功则返回0。否则的话，将返回SOCKET_ERROR错误，应用程序可通过WSAGetLastError()来获取相应的错误代码。<br>错误代码：<br>WSANOTINITIALISED 在调用本API之前应成功调用WSAStartup()。<br>WSAENETDOWN 网络子系统失效。<br>WSAEINVAL 参数中有非法值。<br>WSAEINPROGRESS 一个阻塞的WinSock调用正在进行中，或者服务提供者仍在处理一个回调函数WSAENOBUFS 所提供的缓冲区太小。</p>
<h2 id="TCP参数参数调优"><a href="#TCP参数参数调优" class="headerlink" title="TCP参数参数调优"></a>TCP参数参数调优</h2><p>三次握手建立连接的首要目的是「同步序列号」。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/622683704">参考链接</a></p>
<h2 id="函数储备"><a href="#函数储备" class="headerlink" title="函数储备"></a>函数储备</h2><p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-setsockopt">官方文档</a></p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h3><pre><code>int socket(int af, int type, int protocol);
</code></pre>
<ol>
<li><p>[af] 为地址族(Address Family)，也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。<br>你也可以使用 PF 前缀，PF 是“Protocol Family”的简写，它和 AF 是一样的。例如，PF_INET 等价于 AF_INET，PF_INET6 等价于 AF_INET6。</p>
</li>
<li><p>[type] 为数据传输方式&#x2F;套接字类型，常用的有 <code> SOCK_STREAM (流格式套接字/面向连接的套接字)</code> 和 <code> SOCK_DGRAM (数据报套接字/无连接的套接字)</code><br>SOCK_STREAM	Tcp连接，提供序列化的、可靠的、双向连接的字节流。支持带外数据传输<br>SOCK_DGRAM	支持UDP连接(无连接状态的消息)<br>SOCK_SEQPACKET	序列化包，提供一个序列化的、可靠的、双向的基本连接的数据传输通道，数据长度定常。每次调用读系统调用时数据需要将全部数据读出<br>SOCK_RAW	RAW类型，提供原始网络协议访问<br>SOCK_RDM	提供可靠的数据报文，不过可能数据会有乱序<br>SOCK_PACKET	这是一个专用类型，不能呢过在通用程序中使用<br>并不是所有的协议族都实现了这些协议类型，例如，AF_INET协议族就没有实现SOCK_SEQPACKET协议类型。</p>
</li>
<li><p>[protocol] 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP ，分别表示 TCP 传输协议和 UDP 传输协议。如果指定为0,那么系统就会根据地址格式和套接类别,自动选择一个合适的协议.这是推荐使用的一种选择协议的方法.</p>
</li>
</ol>
<p>[返回值]若无错误发生，socket()返回引用新套接口的描述字。否则的话，返回INVALID_SOCKET错误，应用程序可通过WSAGetLastError()获取相应错误代码。</p>
<h3 id="ioctlsocket"><a href="#ioctlsocket" class="headerlink" title="ioctlsocket()"></a>ioctlsocket()</h3><p>设置socket的模式。</p>
<pre><code>int ioctlsocket( int s, long cmd, u_long * argp);
</code></pre>
<p>s：一个标识套接口的描述字。<br>cmd：对套接口s的操作命令。<br>argp：指向cmd命令所带参数的指针。</p>
<p>cmd：</p>
<ul>
<li>FIONBIO：<br>允许或禁止套接口s的非阻塞模式。argp指向一个无符号长整型，如允许非阻塞模式则非零，如禁止非阻塞模式则为零。当创建一个套接口时，它就处于阻塞模式(也就是说非阻塞模式被禁止)。这与BSD套接口是一致的。WSAAsyncSelect()函数将套接口自动设置为非阻塞模式。如果已对一个套接口进行了WSAAsyncSelect() 操作，则任何用ioctlsocket()来把套接口]重新设置成阻塞模式的试图将以WSAEINVAL失败。为了把套接口重新设置成阻塞模式，应用程序必须首先用WSAAsyncSelect()调用(IEvent参数置为0)来禁止WSAAsyncSelect()。</li>
<li>FIONREAD：<br>确定套接口s自动读入的数据量。argp指向一个无符号长整型，其中存有ioctlsocket()的返回值。如果s是SOCKET_STREAM类型，则FIONREAD返回在一次recv()中所接收的所有数据量。这通常与套接口中排队的数据总量相同。如果S是SOCK_DGRAM 型，则FIONREAD返回套接口上排队的第一个数据报大小。</li>
<li>SIOCATMARK：<br>确认是否所有的带外数据都已被读入。这个命令仅适用于SOCK_STREAM类型的套接口，且该套接口已被设置为可以在线接收带外数据(SO_OOBINLINE)。如无带外数据等待读入，则该操作返回TRUE真。否则的话返回FALSE假，下一个recv()或recvfrom()操作将检索“标记”前一些或所有数据。应用程序可用SIOCATMARK操作来确定是否有数据剩下。如果在“紧急”(带外)数据[前有常规数据，则按序接收这些数据(请注意，recv()和recvfrom()操作不会在一次调用中混淆常规数据与带外数]据)。argp指向一个BOOL型数，ioctlsocket()在其中存入返回值。</li>
</ul>
<p>设置非阻塞：</p>
<pre><code>int sockfd = socket(AF_INET, SOCK_STREAM, 0);
u_long mode = 1;
ioctlsocket(sockfd, FIONBIO, &amp;mode);//设置非阻塞
</code></pre>
<h3 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt()"></a>setsockopt()</h3><p>设置套接口的选项。<br>    #include &lt;sys&#x2F;types.h&gt;<br>    #include &lt;sys&#x2F;socket.h&gt;</p>
<pre><code>int setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);
</code></pre>
<p>sockfd：标识一个套接口的描述字。<br>level：选项定义的层次；支持SOL_SOCKET、IPPROTO_TCP、IPPROTO_IP和IPPROTO_IPV6。<br>optname：需设置的选项。<br>optval：指针，指向存放选项待设置的新值的缓冲区。<br>optlen：optval缓冲区长度。</p>
<p>level&#x3D; SOL_SOCKET</p>
<table>
<thead>
<tr>
<th align="left">价值</th>
<th align="center">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SO_BROADCAST</td>
<td align="center">布尔</td>
<td align="left">配置用于发送广播数据的套接字。</td>
</tr>
<tr>
<td align="left">SO_CONDITIONAL_ACCEPT</td>
<td align="center">布尔</td>
<td align="left">启用传入连接将被应用程序接受或拒绝，而不是协议栈。</td>
</tr>
<tr>
<td align="left">SO_DEBUG</td>
<td align="center">布尔</td>
<td align="left">启用调试输出。Microsoft提供程序当前不输出任何调试信息。</td>
</tr>
<tr>
<td align="left">SO_DONTLINGER</td>
<td align="center">布尔</td>
<td align="left">不阻止关闭等待发送未发送的数据。设置此选项等效于将l_onoff设置为零的SO_LINGER 。</td>
</tr>
<tr>
<td align="left">SO_DONTROUTE</td>
<td align="center">布尔</td>
<td align="left">设置是否应该在套接字绑定到的接口上发送传出数据，而不是在其他某个接口上路由。ATM套接字不支持此选项(导致错误)。</td>
</tr>
<tr>
<td align="left">SO_GROUP_PRIORITY</td>
<td align="center">整型</td>
<td align="left">预订的。</td>
</tr>
<tr>
<td align="left">SO_KEEPALIVE</td>
<td align="center">布尔</td>
<td align="left">启用发送套接字连接的保持活动数据包的功能。ATM套接字不支持(导致错误)。</td>
</tr>
<tr>
<td align="left">SO_LINGER</td>
<td align="center">LINGER</td>
<td align="left">如果存在未发送的数据，则保持关闭状态。</td>
</tr>
<tr>
<td align="left">SO_OOBINLINE</td>
<td align="center">布尔</td>
<td align="left">指示应该与常规数据内联返回超出范围的数据。该选项仅对支持带外数据的面向连接的协议有效。有关此主题的讨论，请参阅 协议无关带外数据。</td>
</tr>
<tr>
<td align="left">SO_RCVBUF</td>
<td align="center">整型</td>
<td align="left">指定为接收保留的每个套接字的总缓冲区空间。</td>
</tr>
<tr>
<td align="left">SO_REUSEADDR</td>
<td align="center">布尔</td>
<td align="left">允许套接字绑定到已经使用的地址。有关更多信息，请参见 bind。不适用于ATM插座。</td>
</tr>
<tr>
<td align="left">SO_EXCLUSIVEADDRUSE</td>
<td align="center">布尔</td>
<td align="left">使套接字可以绑定以进行独占访问。不需要管理特权。</td>
</tr>
<tr>
<td align="left">SO_RCVTIMEO</td>
<td align="center">双字</td>
<td align="left">设置用于阻止接收呼叫的超时(以毫秒为单位)。</td>
</tr>
<tr>
<td align="left">SO_SNDBUF</td>
<td align="center">整型</td>
<td align="left">指定为发送保留的每个套接字的总缓冲区空间。</td>
</tr>
<tr>
<td align="left">SO_SNDTIMEO</td>
<td align="center">双字</td>
<td align="left">阻止发送呼叫的超时(以毫秒为单位)。</td>
</tr>
<tr>
<td align="left">SO_UPDATE_ACCEPT_CONTEXT</td>
<td align="center">整型</td>
<td align="left">用侦听套接字的上下文更新接受套接字。</td>
</tr>
<tr>
<td align="left">PVD_CONFIG</td>
<td align="center">取决于服务提供商</td>
<td align="left">该对象存储与套接字s关联的服务提供者的配置信息。此数据结构的确切格式是特定于服务提供商的。</td>
</tr>
</tbody></table>
<p>设置接收超时时间：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nNetTimeout = <span class="number">500</span>;</span><br><span class="line"><span class="comment">//设置接收超时</span></span><br><span class="line"><span class="built_in">setsockopt</span>(hClient ,SOL_SOCKET, SO_RCVTIMEO , (<span class="type">char</span>*) &amp; nNetTimeout, <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<h3 id="sendto"><a href="#sendto" class="headerlink" title="sendto()"></a>sendto()</h3><pre><code>int sendto(int s, const void * msg, int len, unsigned int flags, const struct sockaddr * to, int tolen);
</code></pre>
<p>函数说明：sendto() 用来将数据由指定的socket 传给对方主机. 参数s 为已建好连线的socket, 如果利用UDP协议则不需经过连线操作. 参数msg 指向欲连线的数据内容, 参数flags 一般设0, 详细描述请参考send(). 参数to 用来指定欲传送的网络地址, 结构sockaddr 请参考bind(). 参数tolen 为sockaddr 的结果长度.</p>
<p>返回值：成功则返回实际传送出去的字符数, 失败返回－1, 错误原因存于errno 中.</p>
<p>错误代码：</p>
<pre><code>1、EBADF 参数s 非法的socket 处理代码.
2、EFAULT 参数中有一指针指向无法存取的内存空间.
3、WNOTSOCK canshu s 为一文件描述词, 非socket.
4、EINTR 被信号所中断.
5、EAGAIN 此动作会令进程阻断, 但参数s 的soket 为补课阻断的.
6、ENOBUFS 系统的缓冲内存不足.
7、EINVAL 传给系统调用的参数不正确.
</code></pre>
<h3 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h3><pre><code>int send(int s, const void * msg, int len, unsigned int falgs);
</code></pre>
<p>函数说明：send()用来将数据由指定的socket 传给对方主机. 参数s 为已建立好连接的socket. 参数msg 指向欲连线的数据内容, 参数len 则为数据长度. 参数flags 一般设0, 其他数值定义如下：<br>   MSG_OOB 传送的数据以out-of-band 送出.<br>   MSG_DONTROUTE 取消路由表查询<br>   MSG_DONTWAIT 设置为不可阻断运作<br>   MSG_NOSIGNAL 此动作不愿被SIGPIPE 信号中断.</p>
<p>返回值：成功则返回实际传送出去的字符数, 失败返回-1. 错误原因存于 errno</p>
<p>错误代码：</p>
<pre><code>EBADF 参数s 非合法的socket 处理代码.
EFAULT 参数中有一指针指向无法存取的内存空间
ENOTSOCK 参数s 为一文件描述词, 非socket.
EINTR 被信号所中断.
EAGAIN 此操作会令进程阻断, 但参数s 的socket 为不可阻断.
ENOBUFS 系统的缓冲内存不足
ENOMEM 核心内存不足
EINVAL 传给系统调用的参数不正确.
</code></pre>
<p>send()用于TCP SOCK_STREAM,sendto()用于UDP SOCK_DGRAM, send支持flags:<br>MSG_OOB:send as “Out of Band” data.该数据包优先，可以先接受到,对端会收到SIGURG信号<br>MSG_DONTROUTE:不用路由，只在本地<br>MSG_DONTWAIT:允许让它返回EAGAIN<br>MSG_NOSIGNAL:对方不接收时不会有SIGPIPE信号<br>socket不管在哪端被关闭，send()端都会捕获SIGPIPE信号(除非设置MSG_NOSIGNAL)</p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><pre><code>int bind(int sockfd, const struct sockaddr *addr,socklen_t *addrlen);
</code></pre>
<p>功能描述<br>通常，在一个SOCK_STREAM套接字<code>接收</code>连接之前，必须通过bind()函数用本地地址为套接字命名。</p>
<p>调用bind()函数之后，为socket()函数创建的套接字关联一个相应地址，<code>发送到这个地址的数据可以通过该套接字读取与使用</code>。</p>
<p>当用socket()函数创建套接字以后，套接字在名称空间(网络地址族)中存在，但没有任何地址给它赋值。<br>bind()把用addr指定的地址赋值给用文件描述符代表的套接字sockfd。addrlen指定了以addr所指向的地址结构体的字节长度。一般来说，该操作称为“给套接字命名”。</p>
<p>备注：<br>bind()函数并不是总是需要调用的，只有用户进程想与一个具体的地址或端口相关联的时候才需要调用这个函数。如果用户进程没有这个需要，那么程序可以依赖内核的自动的选址机制来完成自动地址选择，而不需要调用bind()函数，同时也避免不必要的复杂度。在一般情况下，对于<code>服务器进程问题</code>需要调用bind()函数，对于客户进程则不需要调用bind()函数。</p>
<p>套接字的命名规则在不同的网络协议族中有所不同。对于AF_INET参看ip()，对于AF_INET6参看ipv6()，对于AF_INET6参看unix()，对于AF_APPLETALK参看ddp()，对于AF_APPLETALK参看packet()，对于AF_X25参看x25()，对于AF_NETLINK参看netlink()。</p>
<p>传送给参数addr的实际结构依赖于网络协议族。sockaddr结构定义为如下格式：</p>
<p>struct sockaddr {<br>    sa_family_t     sa_family;<br>    char            sa_data[14];<br>}<br>该结构的唯一目的是强制结构指针在addr参数中传送，以避免编译过程出现warning。<br>返回值<br>成功，返回0；出错，返回－1，相应地设定全局变量errno。</p>
<p>错误<br>EACCESS : 地址空间受保护，用户不具有超级用户的权限。<br>EADDRINUSE : 给定的地址正被使用。</p>
<h3 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h3><p>listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以<code>接受其它进程的请求</code>，从而成为一个<code>服务器进程</code>。在TCP服务器编程中listen函数把进程变为一个服务器，并指定相应的套接字变为被动连接。</p>
<p>listen函数在一般在调用bind之后-调用accept之前调用，它的函数原型是：</p>
<pre><code>int listen(int sockfd, int backlog)
</code></pre>
<p>返回：0──成功， -1──失败</p>
<p>参数sockfd<br>被listen函数作用的套接字，sockfd之前由socket函数返回。在被socket函数返回的套接字fd之时，它是一个主动连接的套接字，也就是此时系统假设用户会对这个套接字调用connect函数，期待它主动与其它进程连接，然后在服务器编程中，用户希望这个套接字可以接受外来的连接请求，也就是被动等待用户来连接。由于系统默认时认为一个套接字是主动连接的，所以需要通过某种方式来告诉系统，用户进程通过系统调用listen来完成这件事。<br>参数backlog<br>这个参数涉及到一些网络的细节。在进程正理一个一个连接请求的时候，可能还存在其它的连接请求。因为TCP连接是一个过程，所以可能存在一种半连接的状态，有时由于同时尝试连接的用户过多，使得服务器进程无法快速地完成连接请求。如果这个情况出现了，服务器进程希望内核如何处理呢？<em>内核会在自己的进程空间里维护一个队列以跟踪这些完成的连接但服务器进程还没有接手处理或正在进行的连接</em>，这样的一个队列内核不可能让其任意大，所以必须有一个大小的上限。这个backlog告诉内核使用这个数值作为上限。<br>毫无疑问，服务器进程不能随便指定一个数值，内核有一个许可的范围。这个范围是实现相关的。很难有某种统一，一般这个值会小30以内。</p>
<h3 id="accept-会阻塞"><a href="#accept-会阻塞" class="headerlink" title="accept() 会阻塞"></a>accept() 会阻塞</h3><p>SOCKET accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</p>
<p>参数：<br>sockfd：套接字描述符，该<em>套接口在listen()后监听连接</em>。<br>addr：(可选)指针，指向一缓冲区，其中接收为<em>通讯层所知的连接实体的地址</em>。Addr参数的实际格式由套接口创建时所产生的地址族确定。<br>addrlen：(可选)指针，输入参数，配合addr一起使用，指向存有addr地址长度的整型数。</p>
<p>本函数从<code>sockfd的等待连接队列中抽取第一个连接，创建一个与sockfd同类的新的套接口并返回句柄</code>。<em>如果队列中无等待连接，且套接口为阻塞方式，则accept()阻塞调用进程直至新的连接出现。如果套接口为非阻塞方式且队列中无等待连接，则accept()返回一错误代码</em>。已接受连接的套接口不能用于接受新的连接，原套接口仍保持开放。<br>addr参数为一个返回参数，其中填写的是为通讯层所知的连接实体地址。addr参数的实际格式由通讯时产生的地址族确定。addrlen参数也是一个返回参数，在调用时初始化为addr所指的地址空间；在调用结束时它包含了实际返回的地址的长度(用字节数表示)。该函数与SOCK_STREAM类型的面向连接的套接口一起使用。如果addr与addrlen中有一个为零NULL，将不返回所接受的套接口远程地址的任何信息。</p>
<p>返回值：<br>如果没有错误产生，则accept()返回一个描述所接受包的SOCKET类型的值。否则的话，返回INVALID_SOCKET错误，应用程序可通过调用 WSAGetLastError() 来获得特定的错误代码。<br>如果非阻塞没有接收到将返回 <TODO>。</p>
<p>addrlen所指的整形数初始时包含addr所指地址空间的大小，在返回时它包含实际返回地址的字节长度</p>
<h3 id="sockaddr和sockaddr-in详解"><a href="#sockaddr和sockaddr-in详解" class="headerlink" title="sockaddr和sockaddr_in详解"></a>sockaddr和sockaddr_in详解</h3><p>二者长度一样，都是16个字节，即占用的内存大小是一致的，因此可以互相转化。二者是并列结构，指向sockaddr_in结构的指针也可以指向sockaddr。</p>
<p>sockaddr常用于bind、connect、recvfrom、sendto等函数的参数，指明地址信息，是一种通用的<em>套接字地址</em>。<br>sockaddr_in 是internet环境下套接字的地址形式。所以在网络编程中我们会对sockaddr_in结构体进行操作，使用sockaddr_in来建立所需的信息，最后使用类型转化就可以了。一般先把sockaddr_in变量赋值后，强制类型转换后传入用sockaddr做参数的函数：sockaddr_in用于socket定义和赋值；sockaddr用于函数参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>(_WIN32_WINNT &lt; 0x0600)</span></span><br><span class="line">    <span class="type">short</span>   sin_family;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line">    ADDRESS_FAMILY sin_family;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//(_WIN32_WINNT &lt; 0x0600)</span></span></span><br><span class="line"></span><br><span class="line">    USHORT sin_port;</span><br><span class="line">    IN_ADDR sin_addr;</span><br><span class="line">    CHAR sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125; SOCKADDR_IN, *PSOCKADDR_IN;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span></span><br><span class="line">  &#123;</span><br><span class="line">    __SOCKADDR_COMMON (sa_);	<span class="comment">/* Common data: address family and length.  协议族*/</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];		<span class="comment">/* Address data.  地址+端口号*/</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Structure describing an Internet socket address.  */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span></span><br><span class="line">  &#123;</span><br><span class="line">    __SOCKADDR_COMMON (sin_);           <span class="comment">/* 协议族 */</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port;			<span class="comment">/* Port number. 端口号 */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr;		<span class="comment">/* Internet address. IP地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;.  用于填充的0字节 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr) -</span><br><span class="line">			   __SOCKADDR_COMMON_SIZE -</span><br><span class="line">			   <span class="built_in">sizeof</span> (<span class="type">in_port_t</span>) -</span><br><span class="line">			   <span class="built_in">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">in_addr_t</span> s_addr;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h3><p>函数原型:</p>
<pre><code>int connect(SOCKET s, const struct sockaddr * name, int namelen);
</code></pre>
<p>参数:<br>s：标识一个未连接socket<br>name：指向要连接套接字的sockaddr结构体的指针<br>namelen：sockaddr结构体的字节长度</p>
<p>定义函数：int connect(int sockfd, struct sockaddr * serv_addr, int addrlen);<br>EBADF 参数sockfd 非合法socket处理代码<br>EFAULT 参数serv_addr指针指向无法存取的内存空间<br>ENOTSOCK 参数sockfd为一文件描述词，非socket。<br>EISCONN 参数sockfd的socket已是连线状态<br>ECONNREFUSED 连线要求被server端拒绝。<br>ETIMEDOUT 企图连线的操作超过限定时间仍未有响应。<br>ENETUNREACH 无法传送数据包至指定的主机。<br>EAFNOSUPPORT sockaddr结构的sa_family不正确。<br>EALREADY socket为不可阻塞且先前的连线操作还未完成。</p>
<p>该过程是否会改变 s？<TODO></p>
<h3 id="recv"><a href="#recv" class="headerlink" title="recv()"></a>recv()</h3><pre><code>int recv(SOCKET s, charFAR* buf, int len, int flags);
</code></pre>
<p>不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。该函数的第一个参数指定接收端套接字描述符；<br>第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；<br>第三个参数指明buf的长度；<br>第四个参数一般置0。<br>这里只描述同步Socket的recv函数的执行流程。当应用程序调用recv函数时，<br>(1)recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR，<br>(2)如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就<code>一直等待</code>，直到协议把数据接收完毕。当协议把数据接收完毕，recv函数就把s的接收缓冲中的数据copy到buf中(注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的) [1]  。<br>recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，那么它返回0。<br>注意：在Unix系统下，如果recv函数在等待协议接收数据时网络断开了，那么调用recv的进程会接收到一个SIGPIPE信号，进程对该信号的默认处理是进程终止。</p>
<p>第四个参数可以使用0或者以下类型的组合：置0是不需要使用特殊功能,疑似是阻塞。可以通过setsockopt来设置非阻塞。</p>
<p>MSG_DONTROUTE：send函数使用，告诉IP协议，目的主机在本地网络上，不需要查找路由表。<br>MSG_OOB：可以接收和发送带外数据，没记错的话TCP的数据包中六个标记位中就有这样一个标记位，即URG。<br>MSG_PEEK：表示只是从缓冲区读取内容而不清除缓冲区，也就是说下次读取还是相同的内容，多进程需要读取相同数据的时候可以使用。<br>MSG_WAITALL ： 表示收到了所有数据的时候才从阻塞中返回，使用这个参数的时候，如果没有收到的数据没有达到我们的需求，就会一直阻塞，直到条件满足。</p>
<h3 id="recvfrom"><a href="#recvfrom" class="headerlink" title="recvfrom"></a>recvfrom</h3><pre><code>ssize_t recvfrom(int sockfd,void *buf,size_t len,unsigned int flags, struct sockaddr *from,socklen_t *fromlen); 
</code></pre>
<p>接收一个数据报并保存源地址。<br>ssize_t 相当于 long int，socklen_t 相当于int ，这里用这个名字为的是提高代码的自说明性。</p>
<p>sockfd ：标识一个已连接套接口的描述字。<br>buf ：接收数据缓冲区。<br>len ：缓冲区长度。<br>flags ：调用操作方式。是以下一个或者多个标志的组合体，可通过“ | ”操作符连在一起:<br>    MSG_DONTWAIT ：操作不会被阻塞。<br>    MSG_ERRQUEUE ： 指示应该从套接字的错误队列上接收错误值，依据不同的协议，错误值以某种辅佐性消息的方式传递进来，使用者应该提供足够大的缓冲区。导致错误的原封包通过msg_iovec作为一般的数据来传递。导致错误的数据报原目标地址作为msg_name被提供。错误以sock_extended_err结构形态被使用，定义如下</p>
<pre><code>#define SO_EE_ORIGIN_NONE 0
#define SO_EE_ORIGIN_LOCAL 1
#define SO_EE_ORIGIN_ICMP 2
#define SO_EE_ORIGIN_ICMP6 3
struct sock_extended_err
&#123;
    u_int32_t ee_errno;
    u_int8_t ee_origin;
    u_int8_t ee_type;
    u_int8_t ee_code;
    u_int8_t ee_pad;
    u_int32_t ee_info;
    u_int32_t ee_data;
&#125;;
MSG_PEEK：指示数据接收后，在接收队列中保留原数据，不将其删除，随后的读操作还可以接收相同的数据。
MSG_TRUNC：返回封包的实际长度，即使它比所提供的缓冲区更长， 只对packet套接字有效。
MSG_WAITALL：要求阻塞操作，直到请求得到完整的满足。然而，如果捕捉到信号，错误或者连接断开发生，或者下次被接收的数据类型不同，仍会返回少于请求量的数据。
MSG_EOR：指示记录的结束，返回的数据完成一个记录。
MSG_TRUNC：指明数据报尾部数据已被丢弃，因为它比所提供的缓冲区需要更多的空间。
MSG_CTRUNC：指明由于缓冲区空间不足，一些控制数据已被丢弃。
MSG_OOB：指示接收到out-of-band数据(即需要优先处理的数据)。
MSG_ERRQUEUE：指示除了来自套接字错误队列的错误外，没有接收到其它数据。
</code></pre>
<p>from ：(可选)指针，指向装有源地址的缓冲区。<br>fromlen ：(可选)指针，指向from缓冲区长度值。</p>
<p>若from非零，且套接口为SOCK_DGRAM类型，则发送数据源的地址被复制到相应的sockaddr结构中。fromlen所指向的值初始化时为这个结构的大小，当调用返回时按实际地址所占的空间进行修改。<br>如果没有数据待读，那么除非是非阻塞模式，不然的话套接口将一直等待数据的到来，此时将返回SOCKET_ERROR错误，错误代码是WSAEWOULDBLOCK。用select()或WSAAsynSelect()可以获知何时数据到达。</p>
<p>如果正确接收返回接收到的字节数，失败返回-1.<br>相关函数 recv，recvmsg，send，sendto，socket<br>函数说明:recvfrom()用来接收远程主机经指定的socket传来的数据,并把数据传到由参数buf指向的内存空间,参数len为可接收数据的最大长度.参数flags一般设0,其他数值定义参考recv().参数from用来指定欲传送的网络地址,结构sockaddr请参考bind()函数.参数fromlen为sockaddr的结构长度.<br>返回值:成功则返回接收到的字符数,失败返回-1.</p>
<p>错误代码</p>
<pre><code>EBADF 参数s非合法的socket处理代码
EFAULT 参数中有一指针指向无法存取的内存空间。
ENOTSOCK 参数s为一文件描述词，非socket。
EINTR 被信号所中断。
EAGAIN 此动作会令进程阻断，但参数s的socket为不可阻断。
ENOBUFS 系统的缓冲内存不足
ENOMEM 核心内存不足
EINVAL 传给系统调用的参数不正确。
</code></pre>
<h3 id="htons"><a href="#htons" class="headerlink" title="htons()"></a>htons()</h3><pre><code>#include &lt;arpa/inet.h&gt;　
uint16_t htons(uint16_t hostshort);　
</code></pre>
<p>htons的功能：<br>将一个无符号[短整型]数值转换为网络字节序，即大端模式(big-endian)<br>参数u_short hostshort: 16位无符号整数　返回值:</p>
<pre><code>TCP / IP网络字节顺序.
</code></pre>
<p>htons是把你机器上的整数转换成“网络字节序”， 网络字节序是 big-endian，也就是整数的高位字节存放在内存的低地址处。 而我们常用的 x86 CPU (intel, AMD) 电脑是 little-endian,也就是整数的低位字节放在内存的低字节处。<br>举个例子：<br>假定你的 port 是 0x1234 ,在网络字节序里 这个port放到内存中就应该显示成</p>
<pre><code>addr addr+1
0x12 0x34
</code></pre>
<p>而在x86电脑上，0x1234放到内存中实际是：</p>
<pre><code>addr addr+1
0x34 0x12
</code></pre>
<p>htons 的用处就是把实际内存中的整数存放方式调整成“网络字节序”的方式。</p>
<p>比如我们在输入端口时，参数 hostshort &#x3D; 3306 ，如下：</p>
<pre><code>00001100 11101010 : 3306
</code></pre>
<p>经过该函数后就变成了 59916：</p>
<pre><code>11101010 00001100 : 59916
</code></pre>
<h3 id="htonl"><a href="#htonl" class="headerlink" title="htonl()"></a>htonl()</h3><p>简述：将主机的无符号[长整形]数转换成网络字节顺序。　</p>
<pre><code>#include &lt;arpa/inet.h&gt;
uint32_t htonl(uint32_t hostlong);
</code></pre>
<p>hostlong：主机字节顺序表达的32位数。<br>注释：<br>  本函数将一个32位数从主机字节顺序转换成网络字节顺序。<br>返回值：　<br>      　htonl()返回一个网络字节顺序的值。</p>
<h3 id="inet-ntoa"><a href="#inet-ntoa" class="headerlink" title="inet_ntoa()"></a>inet_ntoa()</h3><p>网络地址转换成“.”点隔的字符串格式</p>
<pre><code>char FAR* PASCAL FAR inet_ntoa( struct in_addr in);
</code></pre>
<p>MSDN上本函数的原型描述为：unsigned long inet_addr( __in const char *cp);<br>in：一个表示Internet主机地址的结构。</p>
<p>本函数将一个用in参数所表示的Internet地址结构转换成以“.” 间隔的诸如“a.b.c.d”的字符串形式。请注意inet_ntoa()返回的字符串存放在WINDOWS套接口实现所分配的内存中。应用程序不应假设该内存是如何分配的。在同一个线程的下一个WINDOWS套接口调用前，数据将保证是有效。<br>返回值：<br>若无错误发生，inet_ntoa()返回一个字符指针。否则的话，返回NULL。其中的数据应在下一个WINDOWS套接口调用前复制出来。</p>
<h3 id="getpeername"><a href="#getpeername" class="headerlink" title="getpeername()"></a>getpeername()</h3><p>The getpeername function retrieves the address of the peer to which a socket is connected.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winsock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getpeername</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  SOCKET   s,</span></span></span><br><span class="line"><span class="params"><span class="function">  sockaddr *name,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="type">int</span>      *namelen</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Parameters</p>
<p>s:<br>A descriptor identifying a connected socket.</p>
<p>name:<br>The SOCKADDR structure that receives the address of the peer.</p>
<p>namelen:<br>A pointer to the size, in bytes, of the name parameter.</p>
<p>Return value</p>
<p>If no error occurs, getpeername returns zero. Otherwise, a value of SOCKET_ERROR is returned, and a specific error code can be retrieved by calling WSAGetLastError.</p>
<h3 id="socketpair"><a href="#socketpair" class="headerlink" title="socketpair"></a>socketpair</h3><p>Linux下的建立流管道通信。</p>
<h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h3><p>int shutdown(int sock, int howto);  &#x2F;&#x2F;Linux<br>int shutdown(SOCKET s, int howto);  &#x2F;&#x2F;Windows</p>
<p>sock 为需要断开的套接字，howto 为断开方式。</p>
<p>howto 在 Linux 下有以下取值：<br>SHUT_RD：断开输入流。套接字无法接收数据（即使输入缓冲区收到数据也被抹去），无法调用输入相关函数。<br>SHUT_WR：断开输出流。套接字无法发送数据，但如果输出缓冲区中还有未传输的数据，则将传递到目标主机。<br>SHUT_RDWR：同时断开 I&#x2F;O 流。相当于分两次调用 shutdown()，其中一次以 SHUT_RD 为参数，另一次以 SHUT_WR 为参数。</p>
<p>howto 在 Windows 下有以下取值：<br>SD_RECEIVE：关闭接收操作，也就是断开输入流。<br>SD_SEND：关闭发送操作，也就是断开输出流。<br>SD_BOTH：同时关闭接收和发送操作。</p>
<p>至于什么时候需要调用 shutdown() 函数，下节我们会以文件传输为例进行讲解。<br>close()&#x2F;closesocket()和shutdown()的区别<br>确切地说，close() &#x2F; closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与C语言中的 fclose() 类似。应用程序关闭套接字后，与该套接字相关的连接和缓存也失去了意义，TCP协议会自动触发关闭连接的操作。</p>
<p>shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() &#x2F; closesocket() 将套接字从内存清除。</p>
<p>调用 close()&#x2F;closesocket() 关闭套接字时，或调用 shutdown() 关闭输出流时，都会向对方发送 FIN 包。FIN 包表示数据传输完毕，计算机收到 FIN 包就知道不会再有数据传送过来了。</p>
<p>默认情况下，close()&#x2F;closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()&#x2F;closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会。</p>
<p>Once the shutdown function is called to disable send, receive, or both, there is no method to re-enable send or receive for the existing socket connection.</p>
<h1 id="EOF"><a href="#EOF" class="headerlink" title="EOF"></a>EOF</h1>
    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://itheds.github.io">iTheds</a>
            <p>Link：<a href="http://itheds.github.io/2021/04/13/TCP%E4%B8%8EUDP%E5%AE%9E%E7%8E%B0/">http://itheds.github.io/2021/04/13/TCP%E4%B8%8EUDP%E5%AE%9E%E7%8E%B0/</a>
            <p>Publish date：<a href="http://itheds.github.io/2021/04/13/TCP%E4%B8%8EUDP%E5%AE%9E%E7%8E%B0/">April 13th 2021, 12:00:00 am</a>
            <p>Update date：<a href="http://itheds.github.io/2021/04/13/TCP%E4%B8%8EUDP%E5%AE%9E%E7%8E%B0/">July 9th 2024, 10:30:29 am</a>
            <p>License：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2021/04/16/C++%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/" title="C++基本项目开发思路">
                    <div class="nextTitle">C++基本项目开发思路</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2021/04/11/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/" title="开发者手册">
                    <div class="prevTitle">开发者手册</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:itheds@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/iTheds" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="/assets/example_qr.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E4%B8%8EUDP%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.</span> <span class="toc-text">TCP与UDP实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%96%91%E9%97%AE"><span class="toc-number">1.1.</span> <span class="toc-text">疑问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.</span> <span class="toc-text">测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">TCP方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.</span> <span class="toc-text">UDP方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E4%BC%A0%E8%BE%93%E5%8D%95%E5%85%83-MTU"><span class="toc-number">1.5.</span> <span class="toc-text">最大传输单元 MTU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%8C%85%E6%8B%86%E5%8C%85%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">1.6.</span> <span class="toc-text">组包拆包的必要性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85"><span class="toc-number">1.7.</span> <span class="toc-text">粘包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">分包问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.9.</span> <span class="toc-text">阻塞模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.10.</span> <span class="toc-text">缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%A1%A8"><span class="toc-number">1.11.</span> <span class="toc-text">数据表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B7%A5%E5%85%B7"><span class="toc-number">1.12.</span> <span class="toc-text">函数工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">如何判断连接断开？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E7%AB%AF%E5%8F%A3%E4%B8%80%E5%AF%B9%E5%A4%9A%E8%BF%98%E6%98%AF%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">TCP端口一对多还是一对一？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%A4%9A%E4%B8%AA%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.15.</span> <span class="toc-text">监听多个端口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.16.</span> <span class="toc-text">网络模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E6%A8%A1%E5%9E%8BI-x2F-O%E9%87%8D%E5%8F%A0"><span class="toc-number">1.17.</span> <span class="toc-text">socket模型I&#x2F;O重叠</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.18.</span> <span class="toc-text">select模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Overlapped-I-x2F-O-%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.19.</span> <span class="toc-text">Overlapped I&#x2F;O 事件通知模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3-IOCP"><span class="toc-number">1.20.</span> <span class="toc-text">完成端口 IOCP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-OVERLAPPED"><span class="toc-number">1.20.1.</span> <span class="toc-text">数据结构 OVERLAPPED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CreateIoCompletionPort"><span class="toc-number">1.20.2.</span> <span class="toc-text">CreateIoCompletionPort</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetQueuedCompletionStatus"><span class="toc-number">1.20.3.</span> <span class="toc-text">GetQueuedCompletionStatus</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epoll%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E3%80%81poll%E3%80%81select"><span class="toc-number">1.21.</span> <span class="toc-text">epoll系统调用、poll、select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#windows%E4%BA%8B%E4%BB%B6%E5%87%BD%E6%95%B0"><span class="toc-number">1.22.</span> <span class="toc-text">windows事件函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WSACreateEvent"><span class="toc-number">1.22.1.</span> <span class="toc-text">WSACreateEvent()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WSAWaitForMultipleEvents"><span class="toc-number">1.22.2.</span> <span class="toc-text">WSAWaitForMultipleEvents()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WSAEnumNetworkEvents"><span class="toc-number">1.22.3.</span> <span class="toc-text">WSAEnumNetworkEvents()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%8F%82%E6%95%B0%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-number">1.23.</span> <span class="toc-text">TCP参数参数调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%82%A8%E5%A4%87"><span class="toc-number">1.24.</span> <span class="toc-text">函数储备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket"><span class="toc-number">1.24.1.</span> <span class="toc-text">socket()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ioctlsocket"><span class="toc-number">1.24.2.</span> <span class="toc-text">ioctlsocket()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setsockopt"><span class="toc-number">1.24.3.</span> <span class="toc-text">setsockopt()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendto"><span class="toc-number">1.24.4.</span> <span class="toc-text">sendto()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send"><span class="toc-number">1.24.5.</span> <span class="toc-text">send()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">1.24.6.</span> <span class="toc-text">bind()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen"><span class="toc-number">1.24.7.</span> <span class="toc-text">listen()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accept-%E4%BC%9A%E9%98%BB%E5%A1%9E"><span class="toc-number">1.24.8.</span> <span class="toc-text">accept() 会阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sockaddr%E5%92%8Csockaddr-in%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.24.9.</span> <span class="toc-text">sockaddr和sockaddr_in详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connect"><span class="toc-number">1.24.10.</span> <span class="toc-text">connect()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recv"><span class="toc-number">1.24.11.</span> <span class="toc-text">recv()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recvfrom"><span class="toc-number">1.24.12.</span> <span class="toc-text">recvfrom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#htons"><span class="toc-number">1.24.13.</span> <span class="toc-text">htons()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#htonl"><span class="toc-number">1.24.14.</span> <span class="toc-text">htonl()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inet-ntoa"><span class="toc-number">1.24.15.</span> <span class="toc-text">inet_ntoa()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getpeername"><span class="toc-number">1.24.16.</span> <span class="toc-text">getpeername()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socketpair"><span class="toc-number">1.24.17.</span> <span class="toc-text">socketpair</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shutdown"><span class="toc-number">1.24.18.</span> <span class="toc-text">shutdown()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#EOF"><span class="toc-number">2.</span> <span class="toc-text">EOF</span></a></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 91
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2025 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span>
            <a class="archive-post-title" href="/2025/03/18/OpenEuler/">[Untitled Post]</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span>
            <a class="archive-post-title" href="/2025/03/17/unix%E5%86%85%E6%A0%B8%E6%80%81/">UNIX 内核态</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2024 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/2024/11/10/%E5%BC%B1%E7%BD%91%E6%9D%A1%E4%BB%B6%E6%A8%A1%E6%8B%9F/">弱网条件模拟</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/05</span>
            <a class="archive-post-title" href="/2024/07/05/%E5%85%AC%E7%BD%91ip%E6%98%A0%E5%B0%84/">公网ip映射问题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span>
            <a class="archive-post-title" href="/2024/06/18/hibernate/">Hibernate</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span>
            <a class="archive-post-title" href="/2024/04/17/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E5%85%B1%E4%BA%ABWLAN/">局域网内共享WLAN</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2023 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/12</span>
            <a class="archive-post-title" href="/2023/04/12/VScode_debug/">VScode Debuge</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span>
            <a class="archive-post-title" href="/2023/03/27/big_data&flow_calculation/">大数据和流式计算</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/10</span>
            <a class="archive-post-title" href="/2023/03/10/docker_use/">Docker Used Node</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/02</span>
            <a class="archive-post-title" href="/2023/03/02/skiplist_analyze/">Skiplist Analyze</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/07</span>
            <a class="archive-post-title" href="/2022/11/07/Mysql_Read_record/">Mysql_Read_record</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span>
            <a class="archive-post-title" href="/2022/11/03/Berkeley_Read_record/">Berkeley_Read_record</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span>
            <a class="archive-post-title" href="/2022/09/28/UNIX%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">UNIX系统使用笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/18</span>
            <a class="archive-post-title" href="/2022/08/18/Python%E5%92%8CCpp%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">Python和Cpp混合编程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/10</span>
            <a class="archive-post-title" href="/2022/08/10/TDengine%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/">TDengine技术分析</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/10</span>
            <a class="archive-post-title" href="/2022/03/10/%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%BC%8F%E7%AD%96%E5%88%92%E6%96%B9%E6%A1%88/">学习方式策划方案</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2021 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/17</span>
            <a class="archive-post-title" href="/2021/11/17/QT%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/">QT学习札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/25</span>
            <a class="archive-post-title" href="/2021/08/25/Lib%E5%92%8CDLL%E8%AF%A6%E8%A7%A3/">Lib和DLL详解</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/11</span>
            <a class="archive-post-title" href="/2021/08/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/">算法学习笔记02</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span>
            <a class="archive-post-title" href="/2021/07/24/%E5%8C%97%E4%BA%AC%E9%A3%9F%E5%BA%97%E6%94%B6%E5%BD%95/">北京食店收录</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span>
            <a class="archive-post-title" href="/2021/07/08/Cmake%E5%92%8Cbison/">Cmake和bison</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span>
            <a class="archive-post-title" href="/2021/06/17/mysql%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Mysql源码以及Mysql ODBC源码分析</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2021/06/04/%E5%AD%97%E4%BD%93%E7%89%88%E6%9D%83%E9%97%AE%E9%A2%98/">字体版权问题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2021/06/04/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/">EKF，UKF，CKF，PF非线性滤波算法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span>
            <a class="archive-post-title" href="/2021/05/28/DB_%E6%9C%8D%E5%8A%A1%E5%99%A8_%E6%A1%A5%E9%80%BB%E8%BE%91/">DB 服务器 桥逻辑</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/25</span>
            <a class="archive-post-title" href="/2021/05/25/SQLite/">SQLite</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/18</span>
            <a class="archive-post-title" href="/2021/05/18/Cppwindows%E6%9C%8D%E5%8A%A1/">C/C++windows服务</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/13</span>
            <a class="archive-post-title" href="/2021/05/13/ODBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/">ODBC连接数据库</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/06</span>
            <a class="archive-post-title" href="/2021/05/06/ODBC%E7%90%86%E8%AE%BA/">ODBC理论</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/06</span>
            <a class="archive-post-title" href="/2021/05/06/ODBC%E7%BC%96%E7%A8%8B/">ODBC编程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span>
            <a class="archive-post-title" href="/2021/05/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">智能指针</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span>
            <a class="archive-post-title" href="/2021/04/28/B%E6%A0%91%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/">B树学习札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/27</span>
            <a class="archive-post-title" href="/2021/04/27/Rust%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%89%8E%E8%AE%B0/">Rust编程学习扎记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span>
            <a class="archive-post-title" href="/2021/04/16/C++%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/">C++基本项目开发思路</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span>
            <a class="archive-post-title" href="/2021/04/13/TCP%E4%B8%8EUDP%E5%AE%9E%E7%8E%B0/">TCP与UDP实现</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span>
            <a class="archive-post-title" href="/2021/04/11/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/">开发者手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span>
            <a class="archive-post-title" href="/2021/04/10/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C/">CRC循环冗余校验</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span>
            <a class="archive-post-title" href="/2021/04/10/CCpp%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">C/C++问题收录与知识积累</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/08</span>
            <a class="archive-post-title" href="/2021/03/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/">数据库理论系统学习手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/08</span>
            <a class="archive-post-title" href="/2021/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/">计算机网络具体实现</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/05</span>
            <a class="archive-post-title" href="/2021/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%A5%E9%97%A8%E8%B7%AF%E7%BA%BF/">计算机入门路线(应用篇)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span>
            <a class="archive-post-title" href="/2021/02/06/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Nodejs学习笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2021/02/03/Apache%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/">Apache系统管理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2021/02/03/Linux%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BB%BA%E5%BA%93/">Linux下数据库管理与建库</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2021/02/03/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E9%9B%86%E4%B8%8E%E7%B3%BB%E7%BB%9F/">Linux命令总集与系统</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2021/02/03/%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/">编码总集</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span>
            <a class="archive-post-title" href="/2021/01/21/%E8%BD%AF%E4%BB%B6%E6%80%BB%E9%9B%86/">软件总集以及网站</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/20</span>
            <a class="archive-post-title" href="/2021/01/20/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">英语学习笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/Ps%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/">Ps学习札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/git_use_page/">git 及 github 使用手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/php%E8%BF%9B%E9%98%B6%E6%89%8B%E5%86%8C/">php进阶手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/">工具总结</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/">数据结构具体实现</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/CCpp%E8%BF%9B%E9%98%B6/">C/C++进阶</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/Linux%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">`Linux`编程笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/String%E5%87%BD%E6%95%B0/">C/C++ String函数</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/VS%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">VS C++开发使用笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/%E5%90%84%E8%BD%AF%E4%BB%B6%E5%8F%8Awindows%E6%93%8D%E4%BD%9C%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E9%9B%86/">各软件及windows操作快捷键总集</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/">算法学习笔记01</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2018 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span>
            <a class="archive-post-title" href="/2018/12/06/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">线程与进程管理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span>
            <a class="archive-post-title" href="/2018/10/10/Linux%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8oo/">Linux网络应用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/30</span>
            <a class="archive-post-title" href="/2018/09/30/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5oo/">宽字节注入</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span>
            <a class="archive-post-title" href="/2018/09/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Foo/">正则表达式</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span>
            <a class="archive-post-title" href="/2018/09/05/%E9%AB%98%E9%A2%91%E8%AF%8D%E6%B1%87%E8%A1%A8oo/">高频词汇表</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/30</span>
            <a class="archive-post-title" href="/2018/08/30/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B9%8B%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E8%AE%B0oo/">系统管理之重装系统记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/29</span>
            <a class="archive-post-title" href="/2018/08/29/%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8Coo/">打印机问题及使用方法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span>
            <a class="archive-post-title" href="/2018/08/20/%E6%96%87%E4%BB%B6%E5%A4%B4%E6%96%87%E4%BB%B6%E5%B0%BE%E6%80%BB%E7%BB%93oo/">文件类型以及分析手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/11</span>
            <a class="archive-post-title" href="/2018/08/11/Linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83(lamp%E5%92%8Cshadowsocks%E3%80%81lnmp)oo/">Linux下配置服务器环境(lamp和shadowsocks、lnmp)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span>
            <a class="archive-post-title" href="/2018/07/25/AntDesignPro/">RESTful架构与Ant Design Pro开发项目</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span>
            <a class="archive-post-title" href="/2018/07/25/wiki%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0oo/">Wiki搭建</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span>
            <a class="archive-post-title" href="/2018/07/15/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B6%89%E7%8C%8Eoo/">大数据涉猎</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/07</span>
            <a class="archive-post-title" href="/2018/07/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86oo/">通信原理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span>
            <a class="archive-post-title" href="/2018/06/18/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BAoo/">算法导论</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span>
            <a class="archive-post-title" href="/2018/06/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">编译原理之预测分析器的设计与实现</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span>
            <a class="archive-post-title" href="/2018/06/18/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E6%86%A9/">项目小憩</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/11</span>
            <a class="archive-post-title" href="/2018/06/11/SQL%E8%AF%AD%E5%8F%A5%E6%9C%AD%E8%AE%B0oo/">SQL语句札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/11</span>
            <a class="archive-post-title" href="/2018/06/11/%E5%9F%BA%E4%BA%8EMIPS%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%8432%E4%BD%8D%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1oo/">基于MIPS指令集的32位五级流水线CPU设计</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2018/06/04/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E6%89%AB%E6%8F%8Foo/">攻防安全之扫描</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2018/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86oo/">计算机组成原理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/25</span>
            <a class="archive-post-title" href="/2018/05/25/%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">创新创业项目库管理系统</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span>
            <a class="archive-post-title" href="/2018/05/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90oo/">编译原理之语法分析程序</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/20</span>
            <a class="archive-post-title" href="/2018/05/20/WebCollector%E7%88%AC%E8%99%AB%E4%B8%8EHbase/">WebCollector爬虫与Hbase</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/18</span>
            <a class="archive-post-title" href="/2018/05/18/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86oo/">加密解密的艺术</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/15</span>
            <a class="archive-post-title" href="/2018/05/15/Linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEoo/">配置Linux环境</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span>
            <a class="archive-post-title" href="/2018/05/12/SQL%E6%B3%A8%E5%85%A5/">SQL注入札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span>
            <a class="archive-post-title" href="/2018/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98oo/">数据库中文乱码问题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span>
            <a class="archive-post-title" href="/2018/05/12/%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E6%89%8B%E5%86%8C/">网页状态提示说明</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/10</span>
            <a class="archive-post-title" href="/2018/05/10/hexo%E6%9C%AD%E8%AE%B0/">hexo 札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/08</span>
            <a class="archive-post-title" href="/2018/05/08/DOS%E5%91%BD%E4%BB%A4%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3/">DOS命令扫描指定端口并查看端口号</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2017 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span>
            <a class="archive-post-title" href="/2017/10/18/Markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8Eoo/">markdown语法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span>
            <a class="archive-post-title" href="/2017/07/25/JS%E8%BF%9B%E9%98%B6oo/">JS进阶</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="数据库">
                <span class="iconfont-archer">&#xe606;</span>
                数据库
            </span>
        
            <span class="sidebar-tag-name" data-tags="JAVA">
                <span class="iconfont-archer">&#xe606;</span>
                JAVA
            </span>
        
            <span class="sidebar-tag-name" data-tags="python">
                <span class="iconfont-archer">&#xe606;</span>
                python
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- RTthread">
                <span class="iconfont-archer">&#xe606;</span>
                -- RTthread
            </span>
        
            <span class="sidebar-tag-name" data-tags="Linux">
                <span class="iconfont-archer">&#xe606;</span>
                Linux
            </span>
        
            <span class="sidebar-tag-name" data-tags="unix">
                <span class="iconfont-archer">&#xe606;</span>
                unix
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- C/C++">
                <span class="iconfont-archer">&#xe606;</span>
                -- C/C++
            </span>
        
            <span class="sidebar-tag-name" data-tags="RESTful">
                <span class="iconfont-archer">&#xe606;</span>
                RESTful
            </span>
        
            <span class="sidebar-tag-name" data-tags="Ant Design Pro">
                <span class="iconfont-archer">&#xe606;</span>
                Ant Design Pro
            </span>
        
            <span class="sidebar-tag-name" data-tags="React">
                <span class="iconfont-archer">&#xe606;</span>
                React
            </span>
        
            <span class="sidebar-tag-name" data-tags="前后端分离">
                <span class="iconfont-archer">&#xe606;</span>
                前后端分离
            </span>
        
            <span class="sidebar-tag-name" data-tags="apache">
                <span class="iconfont-archer">&#xe606;</span>
                apache
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- Berkeley">
                <span class="iconfont-archer">&#xe606;</span>
                -- Berkeley
            </span>
        
            <span class="sidebar-tag-name" data-tags="C/C++">
                <span class="iconfont-archer">&#xe606;</span>
                C/C++
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- work -- cmake">
                <span class="iconfont-archer">&#xe606;</span>
                -- work -- cmake
            </span>
        
            <span class="sidebar-tag-name" data-tags="JS">
                <span class="iconfont-archer">&#xe606;</span>
                JS
            </span>
        
            <span class="sidebar-tag-name" data-tags="mysql">
                <span class="iconfont-archer">&#xe606;</span>
                mysql
            </span>
        
            <span class="sidebar-tag-name" data-tags="SQL">
                <span class="iconfont-archer">&#xe606;</span>
                SQL
            </span>
        
            <span class="sidebar-tag-name" data-tags="lamp">
                <span class="iconfont-archer">&#xe606;</span>
                lamp
            </span>
        
            <span class="sidebar-tag-name" data-tags="lnmp">
                <span class="iconfont-archer">&#xe606;</span>
                lnmp
            </span>
        
            <span class="sidebar-tag-name" data-tags="Markdown">
                <span class="iconfont-archer">&#xe606;</span>
                Markdown
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- Mysql">
                <span class="iconfont-archer">&#xe606;</span>
                -- Mysql
            </span>
        
            <span class="sidebar-tag-name" data-tags="hexo">
                <span class="iconfont-archer">&#xe606;</span>
                hexo
            </span>
        
            <span class="sidebar-tag-name" data-tags="git">
                <span class="iconfont-archer">&#xe606;</span>
                git
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- C/C++ -- ODBC">
                <span class="iconfont-archer">&#xe606;</span>
                -- C/C++ -- ODBC
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- C/C++ -- QT">
                <span class="iconfont-archer">&#xe606;</span>
                -- C/C++ -- QT
            </span>
        
            <span class="sidebar-tag-name" data-tags="rust">
                <span class="iconfont-archer">&#xe606;</span>
                rust
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- work">
                <span class="iconfont-archer">&#xe606;</span>
                -- work
            </span>
        
            <span class="sidebar-tag-name" data-tags="Socket网络编程">
                <span class="iconfont-archer">&#xe606;</span>
                Socket网络编程
            </span>
        
            <span class="sidebar-tag-name" data-tags="linux">
                <span class="iconfont-archer">&#xe606;</span>
                linux
            </span>
        
            <span class="sidebar-tag-name" data-tags="project">
                <span class="iconfont-archer">&#xe606;</span>
                project
            </span>
        
            <span class="sidebar-tag-name" data-tags="大数据">
                <span class="iconfont-archer">&#xe606;</span>
                大数据
            </span>
        
            <span class="sidebar-tag-name" data-tags="ocker">
                <span class="iconfont-archer">&#xe606;</span>
                ocker
            </span>
        
            <span class="sidebar-tag-name" data-tags="java">
                <span class="iconfont-archer">&#xe606;</span>
                java
            </span>
        
            <span class="sidebar-tag-name" data-tags="algorithm">
                <span class="iconfont-archer">&#xe606;</span>
                algorithm
            </span>
        
            <span class="sidebar-tag-name" data-tags="wiki">
                <span class="iconfont-archer">&#xe606;</span>
                wiki
            </span>
        
            <span class="sidebar-tag-name" data-tags="信息安全">
                <span class="iconfont-archer">&#xe606;</span>
                信息安全
            </span>
        
            <span class="sidebar-tag-name" data-tags="网络运维">
                <span class="iconfont-archer">&#xe606;</span>
                网络运维
            </span>
        
            <span class="sidebar-tag-name" data-tags="参考文档">
                <span class="iconfont-archer">&#xe606;</span>
                参考文档
            </span>
        
            <span class="sidebar-tag-name" data-tags="Hadoop">
                <span class="iconfont-archer">&#xe606;</span>
                Hadoop
            </span>
        
            <span class="sidebar-tag-name" data-tags="免密登入">
                <span class="iconfont-archer">&#xe606;</span>
                免密登入
            </span>
        
            <span class="sidebar-tag-name" data-tags="CPU">
                <span class="iconfont-archer">&#xe606;</span>
                CPU
            </span>
        
            <span class="sidebar-tag-name" data-tags="--">
                <span class="iconfont-archer">&#xe606;</span>
                --
            </span>
        
            <span class="sidebar-tag-name" data-tags="Mysql">
                <span class="iconfont-archer">&#xe606;</span>
                Mysql
            </span>
        
            <span class="sidebar-tag-name" data-tags="文件类型">
                <span class="iconfont-archer">&#xe606;</span>
                文件类型
            </span>
        
            <span class="sidebar-tag-name" data-tags="算法">
                <span class="iconfont-archer">&#xe606;</span>
                算法
            </span>
        
            <span class="sidebar-tag-name" data-tags="编译原理">
                <span class="iconfont-archer">&#xe606;</span>
                编译原理
            </span>
        
            <span class="sidebar-tag-name" data-tags="计划">
                <span class="iconfont-archer">&#xe606;</span>
                计划
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- English">
                <span class="iconfont-archer">&#xe606;</span>
                -- English
            </span>
        
            <span class="sidebar-tag-name" data-tags="计算机组成原理">
                <span class="iconfont-archer">&#xe606;</span>
                计算机组成原理
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "http://itheds.github.io",
        root: siteMetaRoot,
        author: "iTheds"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20211217"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20211217"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20211217" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
