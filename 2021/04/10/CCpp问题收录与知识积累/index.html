<!DOCTYPE html>
<html lang="en">
    <!-- title -->


    

<!-- keywords -->



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="iTheds">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="iTheds">
    
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="C&#x2F;C++问题收录与知识积累每天晚上必须复盘代码数据，每周进行课题学习。 知识积累可重入函数和不可重入函数什么是不可重入函数？  可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入 OS 调度下去执行另外一段代码，而返回控制时不会出现什么错误; 而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表">
<meta property="og:type" content="article">
<meta property="og:title" content="C&#x2F;C++问题收录与知识积累">
<meta property="og:url" content="http://itheds.github.io/2021/04/10/CCpp%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="C&#x2F;C++问题收录与知识积累每天晚上必须复盘代码数据，每周进行课题学习。 知识积累可重入函数和不可重入函数什么是不可重入函数？  可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入 OS 调度下去执行另外一段代码，而返回控制时不会出现什么错误; 而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-09T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-25T02:42:23.074Z">
<meta property="article:author" content="iTheds">
<meta property="article:tag" content="C&#x2F;C++">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/favicon.ico">
    
    <title>C/C++问题收录与知识积累 · iTheds&#39;s Studio</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link rel="preload" href="/css/style.css?v=20211217" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="/css/dark.css?v=20211217" as="style">
    <link rel="stylesheet" href="/css/dark.css">
    <link rel="stylesheet" href="/css/mobile.css?v=20211217" media="(max-width: 960px)">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js?v=20211217" as="script">
    <link rel="preload" href="/scripts/dark.js?v=20211217" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 6.3.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
    
        <body class="post-body">
    
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        
            <div class="header-sidebar-menu">
        
            
                <div style="padding-left: 1px;">&#xe775;</div>
            
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href=/>iTheds's Studio.</a>
        </span>
    </div>
    <!-- toggle banner for post layout -->
    
        
            <div class="banner">
        
            <div class="blog-title header-element">
                <a href="/">iTheds&#39;s Studio.</a>
            </div>
            <div class="post-title header-element">
                <a href="#" class="post-name">C/C++问题收录与知识积累</a>
            </div>
        </div>
    
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- back to top button -->
    <div class="footer-fixed-element">
        
            <div class="back-top back-top-hidden">
        
        
            <div>&#xe639;</div>
        
        </div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="







    height:50vh;

">
    
    <!-- 主页  -->
    
        
    <!-- 404页  -->
    
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
                C/C++问题收录与知识积累
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
                
                    C++问题收录与知识积累
                
            <!-- 404 -->
            
        </p>
        <!-- 文章页 meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
    
        <a class="post-tag" href="javascript:void(0);" data-tags="C/C++">C/C++</a>
    
</div>

                
                <!-- 文章字数统计 -->
                
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2021/04/10</span>
                    <!-- busuanzi -->
                    
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <h1 id="C-x2F-C-问题收录与知识积累"><a href="#C-x2F-C-问题收录与知识积累" class="headerlink" title="C&#x2F;C++问题收录与知识积累"></a>C&#x2F;C++问题收录与知识积累</h1><p>每天晚上必须复盘代码数据，每周进行课题学习。</p>
<h2 id="知识积累"><a href="#知识积累" class="headerlink" title="知识积累"></a>知识积累</h2><h3 id="可重入函数和不可重入函数"><a href="#可重入函数和不可重入函数" class="headerlink" title="可重入函数和不可重入函数"></a>可重入函数和不可重入函数</h3><p>什么是不可重入函数？</p>
<ul>
<li>可重入函数主要用于多任务环境中，一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入 OS 调度下去执行另外一段代码，而返回控制时不会出现什么错误;</li>
<li>而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。</li>
</ul>
<p>满足下列条件的函数多数是不可重入的：<br>    函数体内使用了静态（static）的数据结构；函数体内调用了 malloc() 或者 free() 函数；函数体内调用了标准 I&#x2F;O 函数;</p>
<p>为什么中断处理函数不能直接调用不可重入函数？</p>
<p>在多任务系统下，中断可能在任务执行的任何时间发生；如果一个函数的执行期间被中断后，到重新恢复到断点进行执行的过程中，函数所依赖的环境没有发生改变，那么这个函数就是可重入的，否则就不可重入。<br>在中断前后不都要保存和恢复上下文吗，怎么会出现函数所依赖的环境发生改变了呢？ 我们知道中断时确实保存一些上下文，但是仅限于返回地址，cpu 寄存器等之类的少量上下文，而函数内部使用的诸如全局或静态变量，buffer 等并不在保护之列，所以如果这些值在函数被中断期间发生了改变，那么当函数回到断点继续执行时，其结果就不可预料了。<br>在中断处理函数中调用有互斥锁保护的全局变量，如果恰好该变量正在被另一个线程调用，会导致中断处理函数不能及时返回，导致中断丢失等严重问题。<br>并且在多线程环境中使用，在没有加锁的情况下，对同一段内存块进行并发读写，就会造成 segmentfault&#x2F;coredump 之类的问题。<br>总而言之，中断处理函数做的事情越简单越好。</p>
<p>如何写出可重入的函数？</p>
<p>在函数体内不访问那些全局变量；<br>如果必须访问全局变量，记住利用互斥信号量来保护全局变量。或者调用该函数前关中断，调用后再开中断；<br>不使用静态局部变量；<br>坚持只使用缺省态（auto）局部变量；<br>在和硬件发生交互的时候，切记关闭硬件中断。完成交互记得打开中断，在有些系列上，这叫做“进入&#x2F;退出核心”或者用 OS_ENTER_KERNAL&#x2F;OS_EXIT_KERNAL 来描述；<br>不能调用任何不可重入的函数；<br>谨慎使用堆栈。最好先在使用前先 OS_ENTER_KERNAL；</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/280711576">Read</a></p>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>A;<br>B vritual A;<br>C vritual A, public B;</p>
<p>当 B 数据赋值到 C 指针时，数据将发生错误。<br>但是如果不是虚继承则不出现该情况。</p>
<h3 id="指针引用的多态"><a href="#指针引用的多态" class="headerlink" title="指针引用的多态"></a>指针引用的多态</h3><p>父类和派生类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CONNECT</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(CONNECT*&amp;)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VioConnect</span> :<span class="keyword">public</span> CONNECT &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	VioConnect v1;	</span><br><span class="line">	VioConnect* new1 = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// v1.set(new1);//error</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//解决方法1</span></span><br><span class="line">	VioConnect v3;</span><br><span class="line">	CONNECT* new2 = <span class="literal">NULL</span>;</span><br><span class="line">	v3.<span class="built_in">set</span>(new2);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//解决方法2</span></span><br><span class="line">	VioConnect*&amp; b1 = <span class="keyword">new</span> <span class="built_in">VioConnect</span>();</span><br><span class="line">	CONNECT* <span class="type">const</span>&amp; a1 = b1;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//根本原因</span></span><br><span class="line">	CONNECT* new_connect_h = <span class="keyword">new</span> <span class="built_in">VioConnect</span>();</span><br><span class="line">	<span class="comment">//VioConnect* v2 = new CONNECT();// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法总结,改写函数 CONNECT::set:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CONNECT</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(CONNECT* <span class="type">const</span> &amp;)</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VioConnect</span> :<span class="keyword">public</span> CONNECT &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="外部变量和静态变量"><a href="#外部变量和静态变量" class="headerlink" title="外部变量和静态变量"></a>外部变量和静态变量</h3><h3 id="String-hash-Code-选取-31-的理由"><a href="#String-hash-Code-选取-31-的理由" class="headerlink" title="String hash Code 选取 31 的理由"></a>String hash Code 选取 31 的理由</h3><ul>
<li>hash 算法中选取 31 是因为其是一个特殊的质数,可以降低哈希算法的冲突率</li>
<li>31、37、41 这三个不大不小的质数，表现都不错，冲突数都低于7个</li>
<li>质数 101 和 199 表现的也很不错，冲突率很低,但是容易溢出，认为他们不是哈希算法的优选乘子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">unsigned</span> <span class="title">stringHashFunction</span><span class="params">(<span class="type">void</span> <span class="type">const</span>* ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> h;</span><br><span class="line">    byte* key = (byte*)ptr;</span><br><span class="line">    <span class="type">int</span> keylen = (<span class="type">int</span>)size;</span><br><span class="line">    <span class="keyword">for</span> (h = <span class="number">0</span>; --keylen &gt;= <span class="number">0</span>; h = h*<span class="number">31</span> + *key++);</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>名著 《Effective Java》第 42 页就有对 hashCode 为什么采用 31 做了说明：</p>
<p>之所以使用 31， 是因为他是一个奇素数。如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算（低位补0）。使用素数的好处并不很明显，但是习惯上使用素数来计算散列结果。 31 有个很好的性能，即用移位和减法来代替乘法，可以得到更好的性能： 31 * i &#x3D;&#x3D; (i &lt;&lt; 5）- i， 现代的 VM 可以自动完成这种优化。这个公式可以很简单的推导出来。</p>
<p>所谓素数：质数又称素数，指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。</p>
<p>素数在使用的时候有一个作用就是，如果我用一个数字来乘以这个素数，那么最终的出来的结果只能被素数本身和被乘数还有1来整除！如：我们选择素数3来做系数，那么3*n只能被3和n或者1来整除，我们可以很容易的通过3n来计算出这个n来。这应该也是一个原因！</p>
<p>HashMap在存储数据计算hash地址的时候，我们希望尽量减少有同样的hash地址，所谓“Hash冲突”。如果使用相同hash地址的数据过多，那么这些数据所组成的hash链就更长，从而降低了查询效率！所以在选择系数的时候要选择尽量长的系数并且让乘法尽量不要溢出的系数，因为如果计算出来的hash地址越大，所</p>
<p>谓的“冲突”就越少，查找起来效率也会提高。</p>
<p>31可以由31 * i &#x3D;&#x3D;  (i &lt;&lt; 5) - i来表示，现在很多虚拟机里面都有做相关优化，使用31的原因可能是为了更好的分配hash地址，并且31只占用5bits！在java乘法中如果数字相乘过大会导致溢出的问题，从而导致数据的丢失，而31则是素数（质数）而且不是很长的数字，最终它被选择为相乘的系数的原因。</p>
<p>可以看到，使用 31 最主要的还是为了性能。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010799123">科普：为什么 String hashCode 方法选择数字31作为乘子</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/mxw2552261/article/details/91349677">hashCode 为什么乘以 31？深入理解 hashCode 和 hash 算法</a></p>
<h3 id="字节对齐"><a href="#字节对齐" class="headerlink" title="字节对齐"></a>字节对齐</h3><p>首先要知道字长模型。<br>这 3 个 64 位模型（LP64、LLP64 和 ILP64）之间的区别在于非浮点数据类型。当一个或多个 C 数据类型的宽度从一种模型变换成另外一种模型时，应用程序可能会受到很多方面的影响。这些影响主要可以分为两类：</p>
<ol>
<li>数据对象的大小。编译器按照自然边界对数据类型进行对齐；换而言之，32 位的数据类型在 64 位系统上要按照 32 位边界进行对齐，而 64 位的数据类型在 64 位系统上则要按照 64 位边界进行对齐。这意味着诸如结构或联合之类的数据对象的大小在 32 位和 64 位系统上是不同的。</li>
<li>基本数据类型的大小。通常关于基本数据类型之间关系的假设在 64 位数据模型上都已经无效了。依赖于这些关系的应用程序在 64 位平台上编译也会失败。例如，sizeof (int) &#x3D; sizeof (long) &#x3D; sizeof (pointer) 的假设对于 ILP32 数据模型有效，但是对于其他数据模型就无效了。<br>总之，编译器要按照自然边界对数据类型进行对齐，这意味着编译器会进行 “填充”，从而强制进行这种方式的对齐，就像是在 C 结构和联合中所做的一样。结构或联合的成员是根据最宽的成员进行对齐的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(8)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ProtecolNet1</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br></pre></td></tr></table></figure>

<h3 id="字长模型"><a href="#字长模型" class="headerlink" title="字长模型"></a>字长模型</h3><table>
<thead>
<tr>
<th align="center">Data Type</th>
<th align="center">ILP32</th>
<th align="center">LP32</th>
<th align="center">ILP64</th>
<th align="center">LP64</th>
<th align="center">LLP64</th>
</tr>
</thead>
<tbody><tr>
<td align="center">宏定义</td>
<td align="center">_</td>
<td align="center">_</td>
<td align="center">_</td>
<td align="center"><strong>LP64</strong></td>
<td align="center"><strong>LLP64</strong></td>
</tr>
<tr>
<td align="center">平台</td>
<td align="center">Win32 API &#x2F; Unix 和 Unix 类的系统 （Linux，Mac OS X）</td>
<td align="center">Win16 API</td>
<td align="center"></td>
<td align="center">Unix 和 Unix 类的系统 （Linux，Mac OS X)</td>
<td align="center">Win64 API</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
<td align="center">16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">32</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">32</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
</tr>
<tr>
<td align="center">pointer</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">64</td>
<td align="center">64</td>
<td align="center">64</td>
</tr>
</tbody></table>
<p>在这张表中，LP64，ILP64，LLP64是64位平台上的字长模型，ILP32和LP32是32位平台上的字长模型。<br>LP64意思是long和pointer是64位，<br>ILP64指int，long，pointer是64位，<br>LLP64指long long和pointer是64-bit的。<br>ILP32指int，long和pointer是32位的，<br>LP32指long和pointer是32位的。</p>
<h3 id="out-of-range"><a href="#out-of-range" class="headerlink" title="out_of_range"></a>out_of_range</h3><h3 id="new-和-malloc-区别"><a href="#new-和-malloc-区别" class="headerlink" title="new 和 malloc 区别"></a>new 和 malloc 区别</h3><p>首先，new分配的是一个结构体或者类，而 malloc 分配的是一个动态分配内存。所以 new 更清楚边界问题，更安全一些。</p>
<p>new 从 自由存储区(free store)上进行动态分配内存，<br>malloc 从 堆(heap)上进行动态分配内存。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/linux_ever/article/details/50533149">参考连接</a></p>
<h3 id="Binary-safe"><a href="#Binary-safe" class="headerlink" title="Binary-safe"></a>Binary-safe</h3><p>Binary-safe is a computer programming term mainly used in connection with string manipulating functions. A binary-safe function is essentially one that treats its input as a raw stream of data without any specific format. It should thus work with all 256 possible values that a character can take (assuming 8-bit characters).</p>
<h3 id="不同头文件之间的类的引用"><a href="#不同头文件之间的类的引用" class="headerlink" title="不同头文件之间的类的引用"></a>不同头文件之间的类的引用</h3><p>首先，两个头文件之间相互引用如果没有使用到各自定义的类是合法的。<br>但如果想要使用各自的类，那么无需互相引用，只需在被引用头文件中声明类，并且在该头文件的类中只允许使用指针。</p>
<p>例如：</p>
<figure class="highlight c++"><figcaption><span>A.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    B* b1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><figcaption><span>B.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="链接器工具错误-LNK2005"><a href="#链接器工具错误-LNK2005" class="headerlink" title="链接器工具错误 LNK2005"></a>链接器工具错误 LNK2005</h3><p>如果在标头文件中的类声明外部定义成员函数，也可能发生此错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LNK2005_member_outside.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sample_function</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Sample::sample_function</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span> * (k % <span class="number">167</span>); &#125;  <span class="comment">// LNK2005</span></span><br></pre></td></tr></table></figure>

<p>若要解决此问题，请将成员函数定义移动到类中。 类声明内定义的成员函数是隐式内联的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LNK2005_member_inline.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sample_function</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span> * (k % <span class="number">167</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><p>首先是关于类内数据的获取方式，直接通过类获取和通过get函数进行返回之间的区别。</p>
<ul>
<li>返回值：返回任意类型的数据类型，会将返回数据做一个拷贝（副本）赋值给变量；由于需要拷贝，所以对于复杂对象这种方式效率比较低（调用对象的拷贝构造函数、析构函数）；例如：int test(){}或者 Point test(){}</li>
<li>返回指针：返回一个指针，也叫指针类型的函数，在返回时只拷贝地址，对于对象不会调用拷贝构造函数和析构函数；例如：int *test(){} 或者 Point *test(){}</li>
<li>返回引用：返回一个引用，也叫引用类型的函数，在返回时只拷贝地址，对于对象不会调用拷贝构造函数和析构函数；例如：int &amp;test(){}或者 Point &amp;test(){}</li>
</ul>
<h3 id="不定参数写法"><a href="#不定参数写法" class="headerlink" title="不定参数写法"></a>不定参数写法</h3><ol>
<li>如果所有类型相同，则直接使用指针进行数据承载。</li>
<li>使用标准库&lt;stdarg.h&gt;， 使用va_list进行承载。</li>
<li>使用Boost::format直接格式化字符串。</li>
</ol>
<h3 id="C-类的六个默认成员函数"><a href="#C-类的六个默认成员函数" class="headerlink" title="C++类的六个默认成员函数"></a>C++类的六个默认成员函数</h3><p>构造函数<br>析构函数<br>拷贝构造函数<br>赋值运算符重载<br>const<br>&amp;及const &amp;重载</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>();<span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a);<span class="comment">//拷贝构造函数</span></span><br><span class="line">    ~<span class="built_in">A</span>();<span class="comment">//析构函数</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a);<span class="comment">//赋值运算符重载</span></span><br><span class="line">    A* <span class="keyword">operator</span> &amp;();<span class="comment">//取地址运算符重载</span></span><br><span class="line">    <span class="type">const</span> A* <span class="keyword">operator</span> &amp;() <span class="type">const</span>;<span class="comment">//const修饰的取地址运算符重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="关于Lib和DLL"><a href="#关于Lib和DLL" class="headerlink" title="关于Lib和DLL"></a>关于Lib和DLL</h3><p>详细见文《Lib和DLL详解》</p>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>extern “C”的主要作用就是为了能够正确实现C++代码调用其他C语言代码。<code>加上extern &quot;C&quot;后，会指示编译器这部分代码按C语言的进行编译，而不是C++的</code>。</p>
<p>由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。</p>
<h3 id="C-extern用法"><a href="#C-extern用法" class="headerlink" title="C extern用法"></a>C extern用法</h3><p>extern int a;<br>说明了a的存储空间是在程序的其他地方分配的，在文件中其他位置或者其他文件中寻找a这个变量</p>
<p>用法<br>一个c文件需要调用另一个c文件里的变量或者函数，而不能从.h文件中调用变量。<br>extern int a &#x3D; 5与int a &#x3D; 5意义是一样的，都是定义。而extern int a;是声明。但会产生一条警告。<br>对于函数而言，和引用变量是一样的，如果需要调用其他.c文件中的函数，在文件中的函数声明前加extern即可，不加extern而直接声明函数也可以，因为声明全局函数默认前面带有extern。<br>如果不想让其他.c文件引用本文件中的变量，加上static即可。</p>
<p>使用extern关键字来声明变量为外部变量。</p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>在VS中项目[配置属性] - [高级] - [字符集]中可以配置属性。<br>有两种常用的分别是宽字符集(Unicode)和多字节字符(ANSI)集。</p>
<h4 id="多字节字符集"><a href="#多字节字符集" class="headerlink" title="多字节字符集"></a>多字节字符集</h4><p>[ASCII字符集]，使用7bits来表示一个字符，可表示128个字符。之后，使用8bits表示一个字符，可以表示256个字符，主要在原来的7 bits字符集的基础上加入了一些特殊符号。<br>[ANSI字符集] 各个国家在ASCII基础上制定的扩展性新编码，这些从ANSI标准派生的字符集被习惯的统称为ANSI字符集，正式的名称是<code>MBCS(Multi-Byte Chactacter System，即多字节字符系统)</code>。<br>这些派生字符集的特点是以ASCII 127 bits为基础，兼容ASCII 127，他们使用大于128的编码作为一个 Leading Byte ，紧跟在 Leading Byte 后的第二(甚至第三)个字符与 Leading Byte一起作为实际的编码。这样的字符集有很多，我们常见的GB-2312就是其中之一。</p>
<h4 id="宽字节字符"><a href="#宽字节字符" class="headerlink" title="宽字节字符"></a>宽字节字符</h4><p>Unicode的学名 是”Universal Multiple-Octet Coded Character Set”，简称为UCS。UCS可以看作是”Unicode Character Set”的缩写。UCS只是规定如何编码，并没有规定如何传输、保存这个编码。UTF是“UCS Transformation Format”的缩写。</p>
<p>[Unicode字符集]有多种编码形式，它固定使用16 bits(两个字节、一个字)来表示一个字符，共可以表示65536个字符。将世界上几乎所有语言的常用字符收录其中，方便了信息交流。<code>标准的Unicode称为UTF-16</code>。后来为了双字节的Unicode能够在现存的处理单字节的系统上正确传输，出现了<code>UTF-8</code>(注意UTF-8是编码，它属于Unicode字符集)，使用类似MBCS的方式对Unicode进行编码。UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元。</p>
<p>UTF-16包括三种：UTF-16，UTF-16BE(Big Endian)，UTF-16LE(Little Endian)，UTF-16 需要通过在文件开头以名为 BOM(Byte Order Mark) 的字符来表明文件是 Big Endian 还是 Little Endian。Unicode 规范中推荐的标记字节顺序的方法是 BOM(Byte Order Mark) 。在UCS编码中有一个叫做”ZERO WIDTH NO-BREAK SPACE”的字符，它的编码是FEFF。而FFFE在UCS中是不存在的字符，所以不应该出现在实际传输中。UCS规范建议我们在传输字节流前，先传输字符”ZERO WIDTH NO-BREAK SPACE”。这样如果接收者收到FEFF，就表明这个字节流是Big-Endian的；如果收到FFFE，就表明这个字节流是Little-Endian的。因此字符”ZERO WIDTH NO-BREAK SPACE”又被称作BOM。</p>
<p>UTF-8不需要BOM来表明字节顺序，但可以用BOM来表明编码方式。字符”ZERO WIDTH NO-BREAK SPACE”的UTF-8编码是EF BB BF(读者可以用我们前面介绍的编码方法验证一下)。所以如果接收者收到以EF BB BF开头的字节流，就知道这是UTF-8编码了。</p>
<p>Windows就是使用BOM来标记文本文件的编码方式的。</p>
<p>L是用来标志一个字符(串)为宽字符(串)，当你在VS2005以上版本的IDE工作时，可以选择工作于这两种不同的编码方式下，而在Unicode方式下，则要对字符(串)常量前添加L来告诉编译器它是宽字符。MS为我们定义了好几个相关的宏：_T(定义于tchar.h)、_TEXT(同样定义于tchar.h)。</p>
<p>对于为什么使用Unicode？(以下引自《windows核心编程》)<br>开发应用程序的时候，强烈建议你使用Unicode字符和字符串，理由如下：</p>
<ul>
<li>Unicode使程序的本地化变得更容易；</li>
<li>使用Unicode，只需发布一个二进制(.exe或DLL)文件，即可支持所有语言；</li>
<li>Unicode代码执行速度更快，占用内存更少，提升了应用程序的效率。自从Windows2K开始，Win的系统内核开始完全支持并完全应用Unicode编写，所有ANSI字符在进入底层前，都会被相应的API转换成Unicode。所以，如果你一开始就使用Unicode，则可以减少转换的用时和RAM开销。</li>
<li>使用Unicode，应用程序能轻松调用所有不反对使用(nondeprecated)的Windows函数，因为一些Windows函数提供了只能处理Unicode字符和字符串的版本；</li>
<li>使用Unicode，代码很容易与COM集成(后者要求使用Unicode字符和字符串)；</li>
<li>使用Unicode，代码很容易与.NET Framework集成(后者要要求使用Unicode字符和字符串)；</li>
<li>使用Unicode，能保证代码能够轻松操纵你自己的资源(其中的字符串总是Unicode的)；</li>
<li>世界上大多数程序用的字符集都是Unicode，Unicode有利于程序国际化和标准化；</li>
</ul>
<p>BOM头：<br>BOM是用来判断文本文件是哪一种Unicode编码的标记，其本身是一个Unicode字符（”\uFEFF”），位于文本文件头部。</p>
<p>虽然BOM字符起到了标记文件编码的作用但是他并不属于文件的内容部分，所以会产生一些问题：</p>
<ol>
<li>在某些使用场景下就会有问题。例如我们把几个JS文件合并成一个文件后，如果文件中间含有BOM字符，就会导致浏览器JS语法错误。</li>
<li>PHP就不能识别bom头，PHP并不会忽略BOM，所以在读取、包含或者引用这些文件时，会把BOM作为该文件开头正文的一部分。根据嵌入式语言的特点，这串字符将被直接执行（显示）出来。由此造成即使页面的 top padding 设置为0，也无法让整个网页紧贴浏览器顶部，因为在html一开头有这3个字符</li>
</ol>
<h3 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h3><p>在HTTP&#x2F;1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源(如JavaScript文件、图像文件、CSS文件等)，每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>而从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p>
<pre><code>Connection:keep-alive
</code></pre>
<p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件(如Apache)中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>
<h3 id="pragma-pack-用法"><a href="#pragma-pack-用法" class="headerlink" title="#pragma pack()用法"></a><code>#pragma pack()</code>用法</h3><p><code>#pragma pack</code> 的主要作用就是改变编译器的内存对齐方式，这个指令在网络报文的处理中有着重要的作用，<code>#pragma pack(n)</code>是他最基本的用法，其作用是改变编译器的对齐方式， 不使用这条指令的情况下，编译器默认采取<code>#pragma pack(8)</code>也就是8字节的默认对齐方式，n值可以取(1, 2, 4, 8, 16) 中任意一值。</p>
<p>单纯使用#pragma pack(push)会将当前的对齐字节数压入栈顶，并设置这个值为新的对齐字节数， 就是说不会改变这个值。<br>而使用#pragma pack(push, n) 会将当前的对齐字节数压入栈顶，并设置n为新的对齐字节数。<br>再就是这个#pragma pack(push, identifier [, n])会在上面的操作基础上为这个对齐字节数附上一个标识符， 这里注意这个标识符只能以($、_、字母)开始， 标识符中可以有($、_、字母、数字)，并且标识符不能是关键字(push， pop可以作为标识符)。这个标识符的作用我会在pop中详细介绍。</p>
<p>同样单纯使用#pragma pack(pop)会弹出栈顶对齐字节数，并设置其为新的内存对齐字节数。<br>使用#pragma pack(pop, n)情况就不同了， 他会弹出栈顶并直接丢弃，设置n为其新的内存对齐字节数。</p>
<p>#pragma pack(pop, identifier [, n])较为复杂，编译器执行这条执行时会从栈顶向下顺序查找匹配的identifier，找到identifier相同的这个数之后将从栈顶到identifier，包括找到identifier全部pop弹出， 若没有找到则不进行任何操作。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d994731f658d">参考连接</a></p>
<h3 id="和-运算符"><a href="#和-运算符" class="headerlink" title="#和##运算符"></a>#和##运算符</h3><p>#: 构串操作符<br><code>#</code>只能修饰带参数的宏的形参，它将实参的字符序列(而不是实参代表的值)转换成字符串常量，允许拼接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构串操作符</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRING(x) #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_O_1(x) #x<span class="string">&quot;bc&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(x) <span class="string">&quot;class&quot;</span>#x<span class="string">&quot;Info&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> abc = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">STRING</span>(abc) &lt;&lt; endl &lt;&lt; <span class="built_in">TEXT</span>(abc) &lt;&lt; endl &lt;&lt; <span class="built_in">STRING</span>(<span class="string">&quot;abc&quot;</span>) </span><br><span class="line">    &lt;&lt; endl &lt;&lt; <span class="built_in">TEST_O_1</span>(aajsivnoiuqhoer)<span class="comment">//支持此类定义</span></span><br><span class="line">    &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>##: 合并操作符<br><code>##</code>将出现在其左右的字符序列合并成一个新的标识符。<br>注意：<br>使用合并操作符##时，自身的标识符必须预先有定义，否则编译器会报“标识符未定义”的编译错误。<br>字符序列合并成新的标识符不是字符串。<br>该标识符体现为变量名。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并操作符</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DATA_VALUE(name) REV_##name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE(x,y,z) x##y##z</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> REV_AIS = <span class="number">2766</span>;</span><br><span class="line"><span class="type">int</span> REV_GPS = <span class="number">2598</span>;</span><br><span class="line"><span class="type">char</span> AIS_rev[<span class="number">25</span>] = <span class="string">&quot;20210730&quot;</span>;</span><br><span class="line">cout &lt;&lt; <span class="built_in">DATA_VALUE</span>(AIS)</span><br><span class="line">    &lt;&lt; endl &lt;&lt; <span class="built_in">DATA_VALUE</span>(GPS)</span><br><span class="line">    &lt;&lt; endl &lt;&lt; <span class="built_in">MERGE</span>(AIS, _, rev)</span><br><span class="line">    &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="calloc-函数"><a href="#calloc-函数" class="headerlink" title="calloc()函数"></a>calloc()函数</h3><p>分配内存空间并初始化</p>
<p>头文件：#include &lt;stdlib.h&gt;</p>
<p>calloc() 函数用来动态地分配内存空间并初始化为 0，其原型为：<br>    void* calloc (size_t num, size_t size);</p>
<p>calloc() 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 num*size 个字节长度的内存空间，并且每个字节的值都是0。</p>
<h3 id="适应多个参数的结构体-x2F-类初始化"><a href="#适应多个参数的结构体-x2F-类初始化" class="headerlink" title="适应多个参数的结构体&#x2F;类初始化"></a>适应多个参数的结构体&#x2F;类初始化</h3><p>主要是通过默认参数实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">aeci_struct_descriptor</span>(</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span>* struct_name_ = <span class="literal">NULL</span>,</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span>* refTableName_ = <span class="literal">NULL</span>,</span><br><span class="line">    aeci_struct_descriptor* structField_ = <span class="literal">NULL</span>,</span><br><span class="line">    <span class="type">char</span> <span class="type">const</span>* structArrayTypeName_ = <span class="literal">NULL</span></span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    struct_name = struct_name_;</span><br><span class="line">    refTableName = refTableName_;</span><br><span class="line">    structField = structField_;</span><br><span class="line">    structArrayTypeName = structArrayTypeName_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fd-set"><a href="#fd-set" class="headerlink" title="fd_set"></a>fd_set</h3><p>select()机制中提供 fd_set 的数据结构，实际上是一个 long 类型的数组，每一个数组元素都能与一打开的文件句柄(不管是socket句柄，还是其他文件或命名管道或设备句柄)建立联系，建立联系的工作由程序员完成，当调用select()时，由内核根据IO状态修改fd_set的内容，由此来通知执行了select()的进程哪一socket或文件发生了可读或可写事件.</p>
<pre><code>#include&lt;winsock.h&gt;
</code></pre>
<h3 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h3><p>fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性</p>
<h3 id="stdcall，-cdecl，-pascal，-fastcall的区别"><a href="#stdcall，-cdecl，-pascal，-fastcall的区别" class="headerlink" title="__stdcall，__cdecl，__pascal，__fastcall的区别"></a>__stdcall，__cdecl，__pascal，__fastcall的区别</h3><p>_cdecl<br>__cdecl 是 C Declaration  的缩写，表示 C 语言默认的函数调用方法：所有参数从右到左依次入栈，这些参数由调用者清除，称为手动清栈。被调用函数不会要求调用者传递多少参数，调用者传递过多或者过少的参数，甚至完全不同的参数都不会产生编译阶段的错误。</p>
<p>__stdcall<br>__stdcall 是 Standard Call 的缩写，是 C++ 的标准调用方式：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是 this 指针。这些堆栈中的参数由被调用的函数在返回后清除，使用的指令是 retnX，X 表示参数占用的字节数，CPU 在 ret 之后自动弹出 X 个字节的堆栈空间，称为自动清栈。函数在编译的时候就必须确定参数个数，并且调用者必须严格的控制参数的生成，不能多，不能少，否则返回后会出错。</p>
<p>__pascal<br>__pascal 是 Pascal 语言（Delphi）的函数调用方式，也可以在 C&#x2F;C++ 中使用，参数压栈顺序与前两者相反。返回时的清栈方式与 __stdcall 相同。</p>
<p>__fastcall<br>__fastcall 是编译器指定的快速调用方式。由于大多数的函数参数个数很少，使用堆栈传递比较费时。因此 __fastcall 通常规定将前两个（或若干个）参数由寄存器传递，其余参数还是通过堆栈传递。不同编译器编译的程序规定的寄存器不同，返回方式和 __stdcall 相当。</p>
<p>__thiscall<br>__thiscall 是为了解决类成员调用中 this 指针传递而规定的。__thiscall 要求把 this 指针放在特定寄存器中，该寄存器由编译器决定。VC 使用 ecx，Borland 的 C++ 编译器使用 eax。返回方式和 __stdcall 相当。</p>
<h3 id="ExitThread-TerminateProcess-ExitProcess"><a href="#ExitThread-TerminateProcess-ExitProcess" class="headerlink" title="ExitThread TerminateProcess ExitProcess"></a>ExitThread TerminateProcess ExitProcess</h3><p>TerminateProcess()是异步执行的，在调用返回后并不能确定被终止进程是否已经真的退出，如果调用TerminateProcess()的进程对此细节关心，可以通过WaitForSingleObject()来等待进程的真正结束。</p>
<p>Windows下return，exit和ExitProcess的区别和分析<br>采用return来结束进程可以正确的析构全局和局部对象。而采用exit()来结束进程时全局对象可以正确析构，但局部对象没有正确析构。采用ExitProcess(0)结束时全局和局部对象都没有正确析构。</p>
<p>在Windows下，return 0 的实际执行过程是： </p>
<ol>
<li>先析构main函数内的局部对象。</li>
<li>返回至调用main的函数。</li>
<li>调用exit函数，由exit函数调用doexit函数，在doexit函数中完成对全局对象的析构。</li>
<li>最后调用ExitProcess结束进程。</li>
</ol>
<p>所以，ExitProcess不负责任何对象的析构，exit只负责析构全局对象，return 0可以析构局部对象并调用exit，因此能析构全部对象。</p>
<h3 id="非阻塞输入"><a href="#非阻塞输入" class="headerlink" title="非阻塞输入"></a>非阻塞输入</h3><h3 id="enum的遍历和toString"><a href="#enum的遍历和toString" class="headerlink" title="enum的遍历和toString"></a>enum的遍历和toString</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">shell_command</span> &#123;</span><br><span class="line">	com_beg = <span class="number">0</span>,</span><br><span class="line">	show,</span><br><span class="line">	restart,</span><br><span class="line">	com_end</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">shell_command</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = com_beg; i &lt;= com_end; i = (shell_command)(i+<span class="number">1</span>) ) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span> , i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>; </span><br></pre></td></tr></table></figure>

<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><p>在文件中间进行读写。覆盖和追加。</p>
<h3 id="管道Pipe"><a href="#管道Pipe" class="headerlink" title="管道Pipe"></a>管道Pipe</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CreatePipe</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_     PHANDLE hReadPipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_     PHANDLE hWritePipe,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_opt_  LPSECURITY_ATTRIBUTES lpPipeAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_      DWORD nSize</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>用于父进程与子进程间的通信时，主要使用继承的方式。<br>子进程通过设置，bInheritHandles为TRUE。并且CreatePipe设置SECURITY_ATTRIBUTES saAttr.bInheritHandle &#x3D; TRUE; ，实现一整套继承体系。</p>
<p>WriteFile 和ReadFile 用于此类的读和写。</p>
<p>::: info<br>bInheritHandles<br>如果此参数为 TRUE，则调用进程中的每个可继承句柄都由新进程继承。如果参数为 FALSE，则不继承句柄。请注意，继承的句柄与原始句柄具有相同的值和访问权限。有关可继承句柄的其他讨论，请参阅备注。<br>终端服务：  您不能跨会话继承句柄。此外，如果此参数为 TRUE，则您必须在与调用方相同的会话中创建进程。<br>:::</p>
<h3 id="线程与进程问题"><a href="#线程与进程问题" class="headerlink" title="线程与进程问题"></a>线程与进程问题</h3><p>查看另一篇文档&lt;线程与进程管理&gt;</p>
<h3 id="函数char-参数改变指针内容"><a href="#函数char-参数改变指针内容" class="headerlink" title="函数char*参数改变指针内容"></a>函数char*参数改变指针内容</h3><p>函数使用<code>char * &amp;p</code>或者<code>char **p</code>的方式实现。直接传递指针，指针也是作为形参传递的，使用malloc并不会改变指针指向。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shell_1</span><span class="params">(<span class="type">char</span> * &amp;p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">char</span>* q = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">char</span>)*<span class="number">25</span>);</span><br><span class="line">	q = <span class="string">&quot;12341251261&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;shell_1 : &quot;</span> &lt;&lt; p &lt;&lt; <span class="string">&quot; , &quot;</span> &lt;&lt; &amp;p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>C语言中的异常处理，setjmp()函数与longjmp()函数。</p>
<p>C++中的异常处理，try catch。<br>但是无法处理使用空指针，除数为零的情况。</p>
<p>C++中可以处理的异常：</p>
<table>
<thead>
<tr>
<th align="center">异常名称</th>
<th align="left">说  明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">logic_error</td>
<td align="left">逻辑错误。</td>
</tr>
<tr>
<td align="center">runtime_error</td>
<td align="left">运行时错误。</td>
</tr>
<tr>
<td align="center">bad_alloc</td>
<td align="left">使用 new 或 new[ ] 分配内存失败时抛出的异常。</td>
</tr>
<tr>
<td align="center">bad_typeid</td>
<td align="left">使用 typeid 操作一个 NULL 指针，而且该指针是带有虚函数的类，这时抛出 bad_typeid 异常。</td>
</tr>
<tr>
<td align="center">bad_cast</td>
<td align="left">使用 dynamic_cast 转换失败时抛出的异常。</td>
</tr>
<tr>
<td align="center">ios_base::failure</td>
<td align="left">io 过程中出现的异常。</td>
</tr>
<tr>
<td align="center">bad_exception</td>
<td align="left">这是个特殊的异常，如果函数的异常列表里声明了 bad_exception 异常，当函数内部抛出了异常列表中没有的异常时，如果调用的 unexpected() 函数中抛出了异常，不论什么类型，都会被替换为 bad_exception 类型。</td>
</tr>
</tbody></table>
<p> logic_error 的派生类： </p>
<table>
<thead>
<tr>
<th align="center">异常名称</th>
<th align="left">说  明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">length_error</td>
<td align="left">试图生成一个超出该类型最大长度的对象时抛出该异常，例如 vector 的 resize 操作。</td>
</tr>
<tr>
<td align="center">domain_error</td>
<td align="left">参数的值域错误，主要用在数学函数中，例如使用一个负值调用只能操作非负数的函数。</td>
</tr>
<tr>
<td align="center">out_of_range</td>
<td align="left">超出有效范围。</td>
</tr>
<tr>
<td align="center">invalid_argument</td>
<td align="left">参数不合适。在标准库中，当利用string对象构造 bitset 时，而 string 中的字符不是 0 或1 的时候，抛出该异常。</td>
</tr>
<tr>
<td align="center">runtime_error 的派生类：</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">异常名称</td>
<td align="left">说  明</td>
</tr>
<tr>
<td align="center">:-:</td>
<td align="left">:-</td>
</tr>
<tr>
<td align="center">range_error</td>
<td align="left">计算结果超出了有意义的值域范围。</td>
</tr>
<tr>
<td align="center">overflow_error</td>
<td align="left">算术计算上溢。</td>
</tr>
<tr>
<td align="center">underflow_error</td>
<td align="left">算术计算下溢。</td>
</tr>
</tbody></table>
<h3 id="LPCTSTR"><a href="#LPCTSTR" class="headerlink" title="LPCTSTR"></a>LPCTSTR</h3><p>L表示long指针 这是为了兼容Windows 3.1等16位操作系统遗留下来的，在win32中以及其他的32位操作系统中， long指针和near指针及far修饰符都是为了兼容的作用。没有实际意义。<br>P表示这是一个指针<br>C表示是一个常量<br>T表示在Win32环境中， 有一个_T宏<br>STR表示这个变量是一个字符串</p>
<h3 id="远程执行windows-server中的程序"><a href="#远程执行windows-server中的程序" class="headerlink" title="远程执行windows server中的程序"></a>远程执行windows server中的程序</h3><p>使用工具psexec，需要开启ipc$和admin$。未试验成功。<br>其中注意PIN与password的区别。</p>
<h3 id="char-和-unsigned-char"><a href="#char-和-unsigned-char" class="headerlink" title="char 和 unsigned char"></a>char 和 unsigned char</h3><p>int 和unsigned int 好理解，一个是有符号位，一个是没有符号位，两者能表示的数据范围都是一样的。<br>同理，ASCII码中，有效位数是[0, 127]，最高位可用于作为奇偶校验。双字节标识中文时，使用了负数范围。<br>一般情况下，使用正数 [0, 127]， unsigned和signed没有什么区别，但是在转换为int的时候，如果是signed ， 那么因为补码负数将会在高位补1，进行扩展。<br>但是如果时unsigned，即使时负数，也不会进行扩展，仍然补0。</p>
<h3 id="关于使用char-转成int型"><a href="#关于使用char-转成int型" class="headerlink" title="关于使用char 转成int型"></a>关于使用char 转成int型</h3><h4 id="1-异或法，范围与int型同"><a href="#1-异或法，范围与int型同" class="headerlink" title="1. 异或法，范围与int型同"></a>1. 异或法，范围与int型同</h4><p>最初的想法是直接通过位移的方式进行低位换算，存到char中；接收之后转换同理。</p>
<ol>
<li>strcat，会将’\0’的数直接代替。出现位数遗失，即截断， char型不完整。<br> 解决方式，使用异或^，并且从1开始。解决该问题。这样就可以减少0的次数。</li>
<li>异或之后，反转的时候一直出现错误，想来可能是补码和原码的问题。一直纠结。也看不到二进制数。<br> 最后才想到使用<code>十六进制</code>输出来查看。<br> 查看之后才发现，异或的时候数据类型已经进行了改变。取出的是1字节，但是已经转换成int， 所以前三个字节也进行了异或？<br> 该方法计数，从127，之后就是-128，7f到7e，</li>
<li>重新梳理一下，我想要找到什么：第一，buffer[i]从开头开始，发生了什么变化；第二，buffer[i]转换后变成了什么。一律使用hex查看。发现，buffer[i]变化的过程接收到的是ffffff80的80，到7e的7e。都是没有经过异或的。所以有时候高位是1，但是有时候高位却是在补0。</li>
<li>其实这就是原码的问题，原码整数不变，但是x的复数是$2^{n}-x$。所以才会有高位补1的情况。唯一方法是进行高位取0。先和0x80000ff相与，去除高位。<br>最后再和下一位buffer[i++]相或。最后得到的整体数据与0xffffffff进行异或。取出数据。</li>
<li>仍然存在截断问题。只是截断的频率变低。</li>
<li>直接使用memcpy,空间直接拷贝,不用担心截断问题.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异或代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">buffer_fetch</span><span class="params">(<span class="type">char</span>* buffer)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">		cout &lt;&lt;dec &lt;&lt; (<span class="type">int</span>)(buffer[i]) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;hex &lt;&lt; (<span class="type">int</span>)(buffer[i]) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;dec &lt;&lt; (<span class="type">int</span>)(buffer[i] ^ <span class="number">0xff</span>) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;hex &lt;&lt; (<span class="type">int</span>)(buffer[i] ^ <span class="number">0xff</span>) &lt;&lt; endl;</span><br><span class="line">		count += (buffer[i] ^ <span class="number">0xffffffff</span>) &lt;&lt; (i * <span class="number">8</span>);</span><br><span class="line">		cout &lt;&lt;dec &lt;&lt; (<span class="type">int</span>)((buffer[i] ^ <span class="number">0xff</span>) &lt;&lt; (i * <span class="number">8</span>)) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt;hex &lt;&lt; (<span class="type">int</span>)((buffer[i] ^ <span class="number">0xff</span>) &lt;&lt; (i * <span class="number">8</span>)) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;count | &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">		buffer[i] = count &gt;&gt; (i * <span class="number">8</span>) ^ <span class="number">0xFF</span>;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Count | &quot;</span> &lt;&lt;hex &lt;&lt; (count &gt;&gt; (i * <span class="number">8</span>) ^ <span class="number">0xFF</span>) &lt;&lt;dec &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Count | &quot;</span> &lt;&lt; (count &gt;&gt; (i * <span class="number">8</span>)) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;buffer | &quot;</span> &lt;&lt; buffer &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;++++++++++++++++++++++++++++++++++++++++++++++&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">buffer_fetch</span>(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-memcpy进行空间复制"><a href="#2-memcpy进行空间复制" class="headerlink" title="2. memcpy进行空间复制"></a>2. memcpy进行空间复制</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码，不会出现截断，可以发送&#x27;\0&#x27;字符串。</span></span><br><span class="line">	<span class="type">char</span> tmp[<span class="number">40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="built_in">memcpy</span>(tmp, &amp;count, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;tmp[<span class="number">4</span>], <span class="string">&quot;$--VHW,2.2,T,3.endl\0&quot;</span> , <span class="number">20</span>);</span><br><span class="line"><span class="comment">//完全没有问题，但是怀疑sendto函数是否可以符合</span></span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;count, buffer, <span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">20</span>;i++) &#123; </span><br><span class="line">		cout &lt;&lt; i &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; buffer[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这三种方法毫无疑问,memcpy是最直接效率最高的。异或的方法可以做为加密的遗留。ASCII码存储没什么参考性，要扩展上限需要通过标识符切割获取更大的数据。</p>
<h4 id="3-存储ASCII码，范围9999"><a href="#3-存储ASCII码，范围9999" class="headerlink" title="3. 存储ASCII码，范围9999"></a>3. 存储ASCII码，范围9999</h4><p>逐步设置代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编码，因为幂运算pow函数对math.h的依赖，自编程需要额外函数，故直接转换。</span></span><br><span class="line">	data[<span class="number">3</span>] = count % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">	data[<span class="number">2</span>] = count/<span class="number">10</span> % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">	data[<span class="number">1</span>] = count/<span class="number">100</span> % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line">	data[<span class="number">0</span>] = count/<span class="number">1000</span> % <span class="number">10</span> + <span class="number">48</span>;</span><br><span class="line"><span class="comment">//解码，直接使用atoi函数。</span></span><br><span class="line">	<span class="type">char</span>* tmp = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	count = <span class="built_in">atoi</span>(<span class="built_in">strncpy</span>( tmp, buffer, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>有些地方需要三目运算符 <code>:</code> 的两边具有相同的返回值.<br>比如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span> != mode) ? <span class="built_in">generateString</span>(dest + current_len, rand_len) : <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>其中, generateString 返回值为 void, 那么该处将报错, 如果采用逗号分割符进行返回最后一个语句, 则有如下写法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span> != mode) ? (<span class="built_in">generateString</span>(dest + current_len, rand_len), <span class="literal">NULL</span>) : <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h3 id="C-cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数"><a href="#C-cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数" class="headerlink" title="C++ cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数"></a>C++ cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数</h3><h3 id="strcat"><a href="#strcat" class="headerlink" title="strcat()"></a>strcat()</h3><p>该函数查找到第一个为’\0’的字符，并且从该字符开始将参数二复制到该字符串中。</p>
<h3 id="int64"><a href="#int64" class="headerlink" title="int64"></a>int64</h3><h3 id="c-中的c-str-用法"><a href="#c-中的c-str-用法" class="headerlink" title="c++中的c_str()用法"></a>c++中的c_str()用法</h3><p>c_str()函数返回一个指向正规C字符串的指针, 内容与本string串相同.<br>这是为了与c语言兼容，在c语言中没有string类型，故必须通过string类对象的成员函数c_str()把string 对象转换成c中的字符串样式。<br>返回之后最好使用strcpy，因为string对象会被析构。</p>
<h3 id="atof"><a href="#atof" class="headerlink" title="atof()"></a>atof()</h3><p>atof()是C 语言标准库中的一个字符串处理函数，功能是把字符串转换成浮点数，所使用的头文件为&lt;stdlib.h&gt;。该函数名是 “ascii to floating point numbers” 的缩写。语法格式为：<br>    double atof(const char *nptr);</p>
<h3 id="itoa"><a href="#itoa" class="headerlink" title="itoa()"></a>itoa()</h3><pre><code>char* itoa(int value,char*string,int radix);//value: 要转换的整数，string: 转换后的字符串,radix: 转换进制数，如2,8,10,16 进制等。
</code></pre>
<h3 id="获取指针所指向的地址中的空间大小"><a href="#获取指针所指向的地址中的空间大小" class="headerlink" title="获取指针所指向的地址中的空间大小"></a>获取指针所指向的地址中的空间大小</h3><p>aeci_field_descriptor： 结构体<br>ais_descriptor：结构体变量<br>descriptor：aeci_field_descriptor*</p>
<pre><code>int tmp = sizeof(ais_descriptor);//1100
int tmp2 = sizeof(aeci_field_descriptor);//440
des_size = sizeof((*descriptor));//440
</code></pre>
<p>无论指针在什么地方指向结构体变量，测量出来的值仍然是该结构体的长度。如果结构体中带有指针并且赋值，那么实际的长度会大于结构体的“表面”大小。</p>
<p>其中sizeof是编译阶段完成的。</p>
<h3 id="迭代器-iterator"><a href="#迭代器-iterator" class="headerlink" title="迭代器 iterator"></a>迭代器 iterator</h3><p>两种方式<br>set:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	set &lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">	s.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">	set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span>(it = s.<span class="built_in">begin</span>(); it != s.<span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;容器中第一个元素是：&quot;</span> &lt;&lt; *s.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;容器中最后一个元素是：&quot;</span> &lt;&lt; *(--s.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vector:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector &lt;<span class="type">int</span>&gt; v;</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">	v.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">	<span class="keyword">for</span>(it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">		cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;容器中第一个元素是：&quot;</span> &lt;&lt; *v.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;容器中最后一个元素是：&quot;</span> &lt;&lt; *(--v.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gjs935219/article/details/81609746">摘自</a></p>
<h3 id="assert-函数"><a href="#assert-函数" class="headerlink" title="assert()函数"></a>assert()函数</h3><p>作用是如果它的条件返回错误，则终止程序执行</p>
<pre><code>#include &lt;assert.h&gt;
void assert( int expression );
</code></pre>
<p>assert的作用是先计算表达式 expression ，如果其值为假(即为0)，那么它先向stderr打印一条出错信息，然后通过调用 abort 来终止程序运行。</p>
<h3 id="ispunct"><a href="#ispunct" class="headerlink" title="ispunct()"></a>ispunct()</h3><pre><code>int ispunct(int c) 
</code></pre>
<p>检查所传的字符是否是标点符号字符。标点符号字符可以是非字母数字(正如 isalnum 中的一样)的任意图形字符(正如 isgraph 中的一样)</p>
<p>C 标准库的 ctype.h 头文件提供了一些函数，可用于测试和映射字符。<br>这些函数接受 int 作为参数，它的值必须是 EOF 或表示为一个无符号字符。<br>如果参数 c 满足描述的条件，则这些函数返回非零(true)。如果参数 c 不满足描述的条件，则这些函数返回零。</p>
<h3 id="assign"><a href="#assign" class="headerlink" title="assign()"></a>assign()</h3><p>C++ string assign()赋值常用方法</p>
<p>函数assign()常用在给string类变量赋值.</p>
<p>常用方法有:</p>
<ol>
<li>直接用另一个字符串赋值.<br>如str2.assign(str1);即用str1给str2赋值.</li>
<li>用另一个字符串的一个子串赋值<br>如str3.assign(str1, 2, 3);</li>
<li>用一个字符串的前一段子串赋值;<br>如str4.assign(“World”, 5);</li>
<li>用几个相同的字符,赋值.<br>如str5.assign(10, ‘c’);</li>
</ol>
<h3 id="string-c-str-和data"><a href="#string-c-str-和data" class="headerlink" title="string c_str()和data()"></a>string c_str()和data()</h3><p>const char* c_str ( ) const;<br>Get C string equivalent<br>Generates a null-terminated sequence of characters (c-string) with the same content as the string object and returns it as a pointer to an array of characters.<br>A terminating null character is automatically appended.</p>
<p>const char* data() const;<br>Get string data<br>Returns a pointer to an array of characters with the same content as the string.<br>Notice that no terminating null character is appended (see member c_str for such a functionality).</p>
<p>第一点：c_str()字符串后有’\0’，而data()没有。<br>第二点： data 能解决 string 串中 包含 ‘\0’ 情况的问题。结合size 方法就能随意访问返回的数据了.  注意他返回的是array 数组.</p>
<h3 id="menset"><a href="#menset" class="headerlink" title="menset()"></a>menset()</h3><pre><code>void *memset(void *s, int ch, size_t n)
</code></pre>
<p>函数说明：将s中前n个字节 (typedef unsigned int size_t )用 ch 替换并返回 s 。<br>经典的置空函数。其中s可以是char* ，也可以是数组，可以是字符串。</p>
<h3 id="stdcall"><a href="#stdcall" class="headerlink" title="__stdcall"></a>__stdcall</h3><p>__stdcall是函数调用约定的一种，函数调用约定主要约束了两件事：<br>1.参数传递顺序<br>2.调用堆栈由谁(调用函数或被调用函数)清理<br>常见的函数调用约定：stdcall cdecl fastcall thiscall naked call<br>__stdcall表示<br>1.参数从右向左压入堆栈<br>2.函数被调用者修改堆栈<br>3.函数名(在编译器这个层次)自动加前导的下划线，后面紧跟一个@符号，其后紧跟着参数的尺寸<br>在win32应用程序里,宏APIENTRY，WINAPI，都表示_stdcall，非常常见。</p>
<h3 id="不固定函数参数int-test-void-x"><a href="#不固定函数参数int-test-void-x" class="headerlink" title="不固定函数参数int test(void* x,...)"></a>不固定函数参数<code>int test(void* x,...)</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> 〈stdarg.h〉\\头文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">demo</span><span class="params">( <span class="type">char</span>, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">( <span class="type">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">　　<span class="built_in">demo</span>(<span class="string">&quot;DEMO&quot;</span>, <span class="string">&quot;This&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;demo!&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ANSI标准形式的声明方式，括号内的省略号表示可选参数*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">demo</span><span class="params">( <span class="type">char</span> msg, ... )</span></span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">　　<span class="comment">/*定义保存函数参数的结构*/</span>   </span><br><span class="line">　　va_list argp;   </span><br><span class="line">　　<span class="type">int</span> argno = <span class="number">0</span>;   </span><br><span class="line">　　<span class="type">char</span> para; 　　   <span class="comment">/*argp指向传入的第一个可选参数，msg是最后一个确定的参数*/</span>   </span><br><span class="line">　　<span class="built_in">va_start</span>( argp, msg );   </span><br><span class="line">　　<span class="keyword">while</span> (<span class="number">1</span>)       </span><br><span class="line">　　&#123;        </span><br><span class="line">　　　　para = <span class="built_in">va_arg</span>( argp, <span class="type">char</span>);</span><br><span class="line">　　　　<span class="keyword">if</span> ( <span class="built_in">strcmp</span>( para, <span class="string">&quot;&quot;</span>) == <span class="number">0</span> )               </span><br><span class="line">    　　　　<span class="keyword">break</span>;</span><br><span class="line">　　　　<span class="built_in">printf</span>(<span class="string">&quot;Parameter #%d is: %s\n&quot;</span>, argno, para);           </span><br><span class="line">　　　　argno++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">va_end</span>( argp ); <span class="comment">/*将argp置为NULL*/</span></span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-x2F-C-中near和far的区别"><a href="#C-x2F-C-中near和far的区别" class="headerlink" title="C&#x2F;C++中near和far的区别"></a>C&#x2F;C++中near和far的区别</h3><p> near关键字创建一个指向可寻址内存低端部分的目标指针。这些指针占用内存的单一字节，并且他们能够指向的内存单元被限制到256个位置，通常是在 0x0000~0x00ff范围中。</p>
<pre><code>  int near * ptr；

  far关键字创建一个能够指向内存中任何数据的指针：

  char far * ptr；
</code></pre>
<p>  near   (近)指针：16位段内偏移地址    </p>
<p>  far(远)指针：16位段地址＋16位段内偏移地址    </p>
<p>  huge(巨)指针：32位规格化的具有唯一性的内存地址  </p>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><p>三种时间计算方法</p>
<h4 id="gettimeofday-微秒-1e-6-s-量级"><a href="#gettimeofday-微秒-1e-6-s-量级" class="headerlink" title="gettimeofday | 微秒(1e-6 s)量级"></a>gettimeofday | 微秒(1e-6 s)量级</h4><p>Linux下的方法。</p>
<p>头文件：#include &lt;sys&#x2F;time.h&gt;    #include &lt;unistd.h&gt;<br>定义函数：int gettimeofday (struct timeval * tv, struct timezone * tz);<br>函数说明：gettimeofday()会把目前的时间有tv 所指的结构返回，当地时区的信息则放到tz 所指的结构中。</p>
<p>timeval 结构定义为：</p>
<pre><code>struct timeval&#123;
    long tv_sec;  //秒
    long tv_usec;  //微秒
&#125;;
</code></pre>
<p>timezone 结构定义为：</p>
<pre><code>struct timezone
&#123;
    int tz_minuteswest;  //和Greenwich 时间差了多少分钟
    int tz_dsttime;  //日光节约时间的状态
&#125;;
</code></pre>
<p>上述两个结构都定义在&#x2F;usr&#x2F;include&#x2F;sys&#x2F;time.h. tz_dsttime 所代表的状态如下</p>
<pre><code>DST_NONE  //不使用
DST_USA  //美国
DST_AUST  //澳洲
DST_WET  //西欧
DST_MET  //中欧
DST_EET  //东欧
DST_CAN  //加拿大
DST_GB  //大不列颠
DST_RUM  //罗马尼亚
DST_TUR  //土耳其
DST_AUSTALT  //澳洲(1986 年以后)
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="built_in">main</span>()&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> tv;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timezone</span> tz;</span><br><span class="line">    <span class="built_in">gettimeofday</span> (&amp;tv, &amp;tz);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tv_sec; %d\n&quot;</span>, tv.tv_sec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tv_usec; %d\n&quot;</span>, tv.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tz_minuteswest; %d\n&quot;</span>, tz.tz_minuteswest);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tz_dsttime, %d\n&quot;</span>, tz.tz_dsttime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GetTickCount-毫秒"><a href="#GetTickCount-毫秒" class="headerlink" title="GetTickCount() | 毫秒"></a>GetTickCount() | 毫秒</h4><p>DWORD GetTickCount();</p>
<p>依赖文件少。<br>检索自系统启动以来经过的毫秒数，最多 49.7 天。<br>GetTickCount64()函数可以获取更多时间的毫秒数。</p>
<h4 id="timeb类-毫秒ms"><a href="#timeb类-毫秒ms" class="headerlink" title="timeb类 | 毫秒ms"></a>timeb类 | 毫秒ms</h4><p>需要头文件timeb.h。</p>
<p>原型:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeb</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span>         time;<span class="comment">//秒</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> millitm;<span class="comment">//毫秒</span></span><br><span class="line">    <span class="type">short</span>          timezone;</span><br><span class="line">    <span class="type">short</span>          dstflag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该类中内容使用一次后则自动销毁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">timeb</span> tp;</span><br><span class="line"><span class="built_in">ftime</span>(&amp;tp);<span class="comment">//一次性销毁</span></span><br></pre></td></tr></table></figure>

<h4 id="基于性能计数器计算-QueryPerformanceCounter-微秒us"><a href="#基于性能计数器计算-QueryPerformanceCounter-微秒us" class="headerlink" title="基于性能计数器计算 QueryPerformanceCounter() | 微秒us"></a>基于性能计数器计算 QueryPerformanceCounter() | 微秒us</h4><p>Retrieves the current value of the performance counter.which is a high resolution (&lt;1us) time stamp that can be used for time-interval measurements.</p>
<p>原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">QueryPerformanceCounter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LARGE_INTEGER *lpPerformanceCount</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中LARGE_INTEGER为int64。相当于获取操作系统一个最小单位的时间计数。</p>
<p>转为int64方法为：<br>    __int64 diff &#x3D; x.QuadPart;</p>
<p>其中配合QueryPerformanceFrequency()得到频率进行计时，可以精确到us。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">stop_watch</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">stop_watch</span>()</span><br><span class="line">		: <span class="built_in">elapsed_</span>(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">QueryPerformanceFrequency</span>(&amp;freq_);</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">stop_watch</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">QueryPerformanceCounter</span>(&amp;begin_time_);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		LARGE_INTEGER end_time;</span><br><span class="line">		<span class="built_in">QueryPerformanceCounter</span>(&amp;end_time);</span><br><span class="line">		elapsed_ += (end_time.QuadPart - begin_time_.QuadPart) * <span class="number">1000000</span> / freq_.QuadPart;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">restart</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		elapsed_ = <span class="number">0</span>;</span><br><span class="line">		<span class="built_in">start</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//微秒</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">elapsed</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(elapsed_);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//毫秒</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">elapsed_ms</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> elapsed_ / <span class="number">1000.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//秒</span></span><br><span class="line">	<span class="function"><span class="type">double</span> <span class="title">elapsed_second</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> elapsed_ / <span class="number">1000000.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	LARGE_INTEGER freq_;</span><br><span class="line">	LARGE_INTEGER begin_time_;</span><br><span class="line">	<span class="type">long</span> <span class="type">long</span> elapsed_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="time-t-得到格式化的时间-毫秒"><a href="#time-t-得到格式化的时间-毫秒" class="headerlink" title="time_t 得到格式化的时间 | 毫秒"></a>time_t 得到格式化的时间 | 毫秒</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">time_t</span> rawtime;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> *info;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">time</span>( &amp;rawtime );</span><br><span class="line"></span><br><span class="line">info = <span class="built_in">localtime</span>( &amp;rawtime );</span><br><span class="line"></span><br><span class="line"><span class="built_in">strftime</span>(buffer, <span class="number">80</span>, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, info);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">time_t</span> star_time;</span><br><span class="line"><span class="type">time_t</span> end_time;</span><br><span class="line"></span><br><span class="line">star_time = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">end_time = <span class="built_in">clock</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="built_in">double</span>(end_time - star_time) / CLOCKS_PER_SEC); <span class="comment">//秒</span></span><br></pre></td></tr></table></figure>

<h4 id="timeval-微秒"><a href="#timeval-微秒" class="headerlink" title="timeval | 微秒"></a>timeval | 微秒</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;winsock.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure used in select() call, taken from the BSD file sys/time.h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span> &#123;</span><br><span class="line">        <span class="type">long</span>    tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">        <span class="type">long</span>    tv_usec;        <span class="comment">/* and microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="“-gt-”-和-“-”-的区别"><a href="#“-gt-”-和-“-”-的区别" class="headerlink" title="“-&gt;” 和 “.” 的区别"></a>“-&gt;” 和 “.” 的区别</h3><p>a.b: a为结构体或者类，里面有名为b的参数<br>a-&gt;b：a为指针，指向一个内部的数据。</p>
<h3 id="Subordinates-是什么"><a href="#Subordinates-是什么" class="headerlink" title="Subordinates 是什么"></a>Subordinates 是什么</h3><h3 id="dynamic-cast和static-cast"><a href="#dynamic-cast和static-cast" class="headerlink" title="dynamic_cast和static_cast"></a>dynamic_cast和static_cast</h3><p>当我们从派生类向基类转换时，不管用传统的c语言还是c++转换方式都可以百分百转换成功。但是可怕是<em>向下转换类型</em>，也就是我们从基类向派生类转换，当我们采用传统的C语言和c++转换时，就会出现意想不到的情况，因为<em>转换后派生类自己的方法和属性</em>丢失了，<em>一旦我们去调用派生类的方法和属性</em>那就糟糕了，这就是对类继承关系和内存分配理解不清晰导致的。好在c++增加了static_cast和dynamic_cast运用于继承关系类间的强制转化。</p>
<p>static_cast&lt; new_type &gt;(expression)<br>dynamic_cast&lt; new_type &gt;(expression)<br>备注：new_type为目标数据类型，expression为原始数据类型变量或者表达式。</p>
<p>static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有<em>运行时类型检查来保证转换的安全性</em>。它主要有如下几种用法：<br>①用于类层次结构中基类(父类)和派生类(子类)之间指针或引用的转换。<br>进行上行转换(把派生类的指针或引用转换成基类表示)是安全的；<br>进行下行转换(把基类指针或引用转换成派生类表示)时，由于没有动态类型检查，所以是不安全的。<br>②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。<br>③把空指针转换成目标类型的空指针。<br>④把任何类型的表达式转换成void类型。<br>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性</p>
<p>dynamic_cast&lt; type* &gt;(e)<br>　type必须是一个类类型且必须是一个有效的指针<br>dynamic_cast&lt; type&amp; &gt;(e)<br>type必须是一个类类型且必须是一个左值<br>dynamic_cast&lt; type&amp;&amp; &gt;(e)<br>type必须是一个类类型且必须是一个右值</p>
<p>e的类型必须符合以下三个条件中的任何一个：<br>1、e的类型是目标类型type的公有派生类<br>2、e的类型是目标type的共有基类<br>3、e的类型就是目标type的类型。</p>
<p>如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常(该异常定义在typeinfo标准库头文件中)。e也可以是一个空指针，结果是所需类型的空指针。</p>
<p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换(cross cast)。</p>
<p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</p>
<p>(1)指针类型<br>举例，Base为包含至少一个虚函数的基类，Derived是Base的共有派生类，如果有一个指向Base的指针bp，我们可以在运行时将它转换成指向Derived的指针，代码如下：</p>
<pre><code>if(Derived *dp = dynamic_cast&lt;Derived *&gt;(bp))&#123;
//使用dp指向的Derived对象  
&#125;
else&#123;
//使用bp指向的Base对象  
&#125;
</code></pre>
<p>值得注意的是，在上述代码中，if语句中定义了dp，这样做的好处是可以在一个操作中同时完成类型转换和条件检查两项任务。<br>(2)引用类型<br>因为不存在所谓空引用，所以引用类型的dynamic_cast转换与指针类型不同，在引用转换失败时，会抛出std::bad_cast异常，该异常定义在头文件typeinfo中。</p>
<h3 id="nullptr和NULL"><a href="#nullptr和NULL" class="headerlink" title="nullptr和NULL"></a>nullptr和NULL</h3><p>NULL是一个宏定义，在c和c++中的定义不同，c中NULL为(void*)0,而c++中NULL为整数0；所以在c++中int *p&#x3D;NULL; 实际表示将指针P的值赋为0，而c++中当一个指针的值为0时，认为指针为空指针。</p>
<p>nullptr是一个字面值常量，类型为std::nullptr_t,空指针常数可以转换为任意类型的指针类型。<br>在c++中(void *)不能转化为任意类型的指针，即 int *p&#x3D;(void*)是错误的，但int *p&#x3D;nullptr是正确的，原因<br>对于函数重载：若c++中 (void *)支持任意类型转换，函数重载时将出现问题下列代码中fun(NULL)将不能判断调用哪个函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;1&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">char</span> *p)</span></span>&#123;cout&lt;&lt;<span class="string">&quot;2&quot;</span>;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">NULL</span>);  <span class="comment">//输出1，c++中NULL为整数0</span></span><br><span class="line">    <span class="built_in">fun</span>(<span class="literal">nullptr</span>);<span class="comment">//输出2，nullptr 为空指针常量。是指针类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题索引"><a href="#问题索引" class="headerlink" title="问题索引"></a>问题索引</h2><h3 id="cc1-error-x2F-usr-x2F-local-x2F-include-x2F-x86-64-linux-gnu-Permission-denied"><a href="#cc1-error-x2F-usr-x2F-local-x2F-include-x2F-x86-64-linux-gnu-Permission-denied" class="headerlink" title="cc1: error: &#x2F;usr&#x2F;local&#x2F;include&#x2F;x86_64-linux-gnu: Permission denied"></a>cc1: error: &#x2F;usr&#x2F;local&#x2F;include&#x2F;x86_64-linux-gnu: Permission denied</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 文件名或文件夹名</span><br></pre></td></tr></table></figure>

<h3 id="HEAP-CORRUPTION-DETECTED-after-Normal-block-1375-at-0x0000000000853200-CRT-detected-that-the-application-wrote-to-memory-after-end-of-heap-buffer"><a href="#HEAP-CORRUPTION-DETECTED-after-Normal-block-1375-at-0x0000000000853200-CRT-detected-that-the-application-wrote-to-memory-after-end-of-heap-buffer" class="headerlink" title="HEAP CORRUPTION DETECTED: after Normal block (#1375) at 0x0000000000853200. CRT detected that the application wrote to memory after end of heap buffer."></a>HEAP CORRUPTION DETECTED: after Normal block (#1375) at 0x0000000000853200. CRT detected that the application wrote to memory after end of heap buffer.</h3><h3 id="CRT-detected-that-the-application-wrote-to-memory-after-end-of-heap-buffer"><a href="#CRT-detected-that-the-application-wrote-to-memory-after-end-of-heap-buffer" class="headerlink" title="CRT detected that the application wrote to memory after end of heap buffer."></a>CRT detected that the application wrote to memory after end of heap buffer.</h3><p>如果修改了分配内存以外的内存，在free()的时候就会产生这个错误。<br>例如访问越界等。</p>
<h3 id="debug-assertion-failed-expression-stream-valid"><a href="#debug-assertion-failed-expression-stream-valid" class="headerlink" title="debug assertion failed expression:stream.valid()"></a>debug assertion failed expression:stream.valid()</h3><p>文件不存在</p>
<h3 id="error-C4996‘fopen’-This-function-or-variable-may-be-unsafe-Consider-using-fopen-s-instead-To-disable-deprecation-use-CRT-SECURE-NO-WARNINGS-See-online-help-for-details"><a href="#error-C4996‘fopen’-This-function-or-variable-may-be-unsafe-Consider-using-fopen-s-instead-To-disable-deprecation-use-CRT-SECURE-NO-WARNINGS-See-online-help-for-details" class="headerlink" title="error C4996	‘fopen’: This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details."></a>error C4996	‘fopen’: This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</h3><p>项目 –&gt; XX属性 –&gt; C++  —&gt; 预处理器 –&gt; 在预处理器定义添加“_CRT_SECURE_NO_WARNINGS”</p>
<h3 id="C-类型的值不能用于初始化-类型的实体"><a href="#C-类型的值不能用于初始化-类型的实体" class="headerlink" title="C++ 类型的值不能用于初始化 类型的实体"></a>C++ 类型的值不能用于初始化 类型的实体</h3><p>报错代码如下：<br>char* image_window &#x3D; “Source Image”;<br>char* result_window &#x3D; “Result window”;<br>查了查资料，可能的原因是在VS2017版本中使用这种char<em>的表达方式会造成程序崩溃，所以VS2017对其进行了控件管理。<br>解决方案：<br>1、先将字符使用字符数组进行存储，再使用指针<br>char image[] &#x3D; “Source Image”;<br>char result1[] &#x3D; “Result window”;<br>char</em> image_window &#x3D; image;<br>char* result_window &#x3D; result1;<br>2、在前面加上const<br>const char* image_window &#x3D; “Source Image”;<br>const char* result_window &#x3D; “Result window”;<br>3、右键project -&gt; 属性 -&gt; C&#x2F;C++ -&gt; 语言 -&gt; 符合模式：否</p>
<h3 id="MTD"><a href="#MTD" class="headerlink" title="MTD"></a>MTD</h3><p>C&#x2F;C++ -&gt; 代码生成 -&gt; 运行库(多线程MTD)</p>
<h3 id="包问题"><a href="#包问题" class="headerlink" title="包问题"></a>包问题</h3><p>65535：两个字节最大值。</p>
<p>配置依赖包：属性 -&gt; C&#x2F;C++ -&gt; 常规 -&gt; 附加包含目录：<br>    $(SolutionDir)eXtremeWrap\examples\example;$(SolutionDir)eXtremeWrap;$(SolutionDir)inc;$(SolutionDir)eXtremeWrap\include;$(SolutionDir)eXtremeWrap\extremeDBAPI;$(SolutionDir)eXtremeWrap\examples\example\testcases;%(AdditionalIncludeDirectories)</p>
<h3 id="链接问题"><a href="#链接问题" class="headerlink" title="链接问题"></a>链接问题</h3><p>链接库 -&gt; 常规 -&gt; 附加目录<br>       -&gt; 输入 -&gt; 附加依赖项</p>
<h3 id="非常量引用的初始值必须是左值"><a href="#非常量引用的初始值必须是左值" class="headerlink" title="非常量引用的初始值必须是左值"></a>非常量引用的初始值必须是左值</h3><p>是引用的问题<br>引用（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过在变量名前添加“&amp;”符号来定义。引用具体的使用方法请参考《C++的引用与重载函数》。</p>
<h3 id="帧不在模块中您可以在反汇编窗口-栈和帧指针使用方法"><a href="#帧不在模块中您可以在反汇编窗口-栈和帧指针使用方法" class="headerlink" title="帧不在模块中您可以在反汇编窗口_栈和帧指针使用方法"></a>帧不在模块中您可以在反汇编窗口_栈和帧指针使用方法</h3><p>清理&amp;重新编译项目</p>
<h3 id="dll文件和lib文件"><a href="#dll文件和lib文件" class="headerlink" title="dll文件和lib文件"></a>dll文件和lib文件</h3><p>DLL(Dynamic Link Library)文件，中文叫动态库文件，是程序在运行时所需要调用的库，那么静态库lib文件就是在程序编译时所需要调用的库。</p>
<p>一般的有三个文件,lib、dll、pdb文件，lib文件指定路径就好。而dll文件需要位于exe文件路径中。</p>
<p>这里面到底有什么，为什么总是需要调用？#pragma comment(lib,”ws2_32.lib”)</p>
<p>.lib是一种文件名后缀，代表的是静态数据连接库，在windows操作系统中起到链接程序和函数(或子过程)的作用，相当于Linux中的.a或.o、.so文件。</p>
<h3 id="STL库函数返回值问题"><a href="#STL库函数返回值问题" class="headerlink" title="STL库函数返回值问题"></a>STL库函数返回值问题</h3><p>返回一个char<em>，那么这个空间能保留的时间有多久呢。<br>如果用一个char</em>去接收，而这个char*没有malloc或者初始化一个const char*，那么我们存储的就是一个地址。<br>而char*，被返回，无论函数中是如何定义的，malloc或者初始化，或者数组，都是有一个空间。<br>在某条件下，空间会被释放。<br>疑似使用引用次数？或者智能指针？</p>
<h3 id="winsock-h和winsock2-h重定义问题"><a href="#winsock-h和winsock2-h重定义问题" class="headerlink" title="winsock.h和winsock2.h重定义问题"></a>winsock.h和winsock2.h重定义问题</h3><p>1.查找winsock.h winsock2.h windows.h调用的地方<br>2.确保windows.h包含的地方同时包含winsock2.h(先包含winsock2.h)<br>3.将包含winsock.h的地方修改为包含winsock2.h</p>
<h3 id="关于变量重复定义"><a href="#关于变量重复定义" class="headerlink" title="关于变量重复定义"></a>关于变量重复定义</h3><p>一个变量<br>int x;<br>传递到函数以指针的方式<br>void tmp(int *x);<br>tmp(&amp;x);<br>*x &#x3D; i;即可改变参数。</p>
<p>但是如果在函数中重复定义：<br>    x &#x3D; (int*)malloc(sizeof(int));<br>    *x &#x3D; i;<br>则无法获得其值，将是乱码。</p>
<h3 id="0xC0000374-堆已损坏"><a href="#0xC0000374-堆已损坏" class="headerlink" title="0xC0000374: 堆已损坏"></a>0xC0000374: 堆已损坏</h3><p>一般是由malloc(size)引起的。反复调用函数太多次，内存中存在溢出或者size动态不明确导致。</p>
<h3 id="异常0xcccccccc、0xcdcdcdcd与指针初始化问题"><a href="#异常0xcccccccc、0xcdcdcdcd与指针初始化问题" class="headerlink" title="异常0xcccccccc、0xcdcdcdcd与指针初始化问题"></a>异常0xcccccccc、0xcdcdcdcd与指针初始化问题</h3><p>程序在调试时，可能会报”写入位置0xcccccccc 时发生访问冲突”，或者“写入位置0xcdcdcdcd 时发生访问冲突”，这些问题可能是由于使用了未初始化的指针引起的。<br>候编译发现存在没有初始化的指针，因此就会对该内存赋值0xcdcdcdcd或者0xcccccccc，体现在程序中就是“屯屯屯屯……”和“烫烫烫烫……”，另外，如果是将指针设为空指针，即为指针赋值NULL，出现错误时是0x00000000</p>
<p>debug时VS为了更快得帮程序员检测出内存问题,因此对初始化后的内存和释放后的内存做了一些处理,有:<br>0xcdcdcdcd - Created but not initialised (malloc了,但是没初始化比如说刷成0,没调用构造函数)<br>0xdddddddd - Deleted (你调用了已经delete的内存…)<br>0xfeeefeee - Freed memory set by NT’s heap manager<br>0xcccccccc - Uninitialized locals in VC6 when you compile w&#x2F; &#x2F;GZ0xabababab - Memory following a block allocated by LocalAlloc()</p>
<p>一个单独的指针，char *p，未经过初始化时，其是0xcccccccc，是无法读取内存的，也不能进行比较(p &#x3D;&#x3D; NULL)。但是如果是一个结构体中的指针，虽然也是0xcccccccc，但可以进行比较，此处疑似是已经对其进行了初始化。<br>所以在使用指针时，最好进行初始化char *p &#x3D; NULL;方便后续进行判断，释放指针内存后也应该进行置空(NULL)，防止其访问内存片段。</p>
<h3 id="无法解析的外部符号发生在哪一个时期"><a href="#无法解析的外部符号发生在哪一个时期" class="headerlink" title="无法解析的外部符号发生在哪一个时期"></a>无法解析的外部符号发生在哪一个时期</h3><p>发生在<code>链接</code>过程。</p>
<p>无法解析的外部符号LNK2019:<br>#pragma comment(lib,”ws2_32.lib”)</p>
<p>表示链接wpcap.lib这个库。和在工程设置里写上链入wpcap.lib的效果一样（两种方式等价，或说一个隐式一个显式调用），不过这种方法写的 程序别人在使用你的代码的时候就不用再设置工程settings了。告诉连接器连接的时候要找ws2_32.lib，这样你就不用在linker的lib设置里指定这个lib了。</p>
<p>常用的库有：<br>ws2_32.lib<br>odbc32.lib<br>odbccp32.lib<br>Secur32.lib<br>legacy_stdio_definitions.lib<br>Dnsapi.lib<br>kernel32.lib<br>user32.lib<br>gdi32.lib<br>winspool.lib<br>shell32.lib<br>ole32.lib<br>oleaut32.lib<br>uuid.lib<br>comdlg32.lib<br>advapi32.lib</p>
<h3 id="92559631349317830736831783200707727132248687965119994463780864-000000"><a href="#92559631349317830736831783200707727132248687965119994463780864-000000" class="headerlink" title="-92559631349317830736831783200707727132248687965119994463780864.000000"></a>-92559631349317830736831783200707727132248687965119994463780864.000000</h3><p>输出的时候类型不对。比如flot类型，使用%d输出。</p>
<h3 id="网络包错误-具体是两者发生的冲突"><a href="#网络包错误-具体是两者发生的冲突" class="headerlink" title="网络包错误 具体是两者发生的冲突"></a>网络包错误 具体是两者发生的冲突</h3><p>了解：WIN32_LEAN_AND_MEAN 含义以及用法</p>
<p>宏编译 预处理头 ，经常可以在stdafx.h文件中出现宏定义#define WIN32_LEAN_AND_MEAN，</p>
<p>具体含义就是当项目中包含#include&lt;windows.h&gt;时去除一些头文件的包含。一个重要的演示</p>
<p>例子就是 winsock2.h和windows.h之间有关于_WINSOCKAPI_的重复定义，如果定义了上面的宏编译</p>
<p>就会避免出现重定义，不同的链接的错误</p>
<p>如果在一个项目中出现winsock重复定义的问题，可以按照如下操作：</p>
<p>项目属性》C&#x2F;C++》预处理器 WIN32_LEAN_AND_MEAN</p>

    </article>
    <!-- license -->
    
        <div class="license-wrapper">
            <p>Author：<a href="http://itheds.github.io">iTheds</a>
            <p>Link：<a href="http://itheds.github.io/2021/04/10/CCpp%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">http://itheds.github.io/2021/04/10/CCpp%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/</a>
            <p>Publish date：<a href="http://itheds.github.io/2021/04/10/CCpp%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">April 10th 2021, 12:00:00 am</a>
            <p>Update date：<a href="http://itheds.github.io/2021/04/10/CCpp%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">April 25th 2024, 10:42:23 am</a>
            <p>License：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href="/2021/04/10/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C/" title="CRC循环冗余校验">
                    <div class="nextTitle">CRC循环冗余校验</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href="/2021/03/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/" title="数据库理论系统学习手册">
                    <div class="prevTitle">数据库理论系统学习手册</div>
                </a>
            
        </li>
    </ul>
    <!-- comment -->
    
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->


            

            

            

            <!-- utteranc评论 -->


            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->


            
            

            

        </div>
    
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    
    <!-- Mathjax -->
    
</main>

                <!-- profile -->
                
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
    
        <div class="social">
            
    
        
            
                <a href="mailto:itheds@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/iTheds" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                    
                    <img class="profile-qr" src="/assets/example_qr.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    


        </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    
    <!-- 不蒜子  -->
    
        <div class="busuanzi-container">
            
             
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
            
        </div>
    	
</footer>

        </div>
        <!-- toc -->
        
            <div class="toc-wrapper toc-wrapper-loding" style=







    top:50vh;

>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-x2F-C-%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF"><span class="toc-number">1.</span> <span class="toc-text">C&#x2F;C++问题收录与知识积累</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF"><span class="toc-number">1.1.</span> <span class="toc-text">知识积累</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0%E5%92%8C%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">可重入函数和不可重入函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.1.2.</span> <span class="toc-text">虚继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">指针引用的多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">外部变量和静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-hash-Code-%E9%80%89%E5%8F%96-31-%E7%9A%84%E7%90%86%E7%94%B1"><span class="toc-number">1.1.5.</span> <span class="toc-text">String hash Code 选取 31 的理由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-number">1.1.6.</span> <span class="toc-text">字节对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%95%BF%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.7.</span> <span class="toc-text">字长模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#out-of-range"><span class="toc-number">1.1.8.</span> <span class="toc-text">out_of_range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%92%8C-malloc-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.9.</span> <span class="toc-text">new 和 malloc 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-safe"><span class="toc-number">1.1.10.</span> <span class="toc-text">Binary-safe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E7%B1%BB%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">1.1.11.</span> <span class="toc-text">不同头文件之间的类的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E5%B7%A5%E5%85%B7%E9%94%99%E8%AF%AF-LNK2005"><span class="toc-number">1.1.12.</span> <span class="toc-text">链接器工具错误 LNK2005</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">1.1.13.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%AE%9A%E5%8F%82%E6%95%B0%E5%86%99%E6%B3%95"><span class="toc-number">1.1.14.</span> <span class="toc-text">不定参数写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%B1%BB%E7%9A%84%E5%85%AD%E4%B8%AA%E9%BB%98%E8%AE%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.15.</span> <span class="toc-text">C++类的六个默认成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ELib%E5%92%8CDLL"><span class="toc-number">1.1.16.</span> <span class="toc-text">关于Lib和DLL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extern-%E2%80%9CC%E2%80%9D"><span class="toc-number">1.1.17.</span> <span class="toc-text">extern “C”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-extern%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.18.</span> <span class="toc-text">C extern用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.1.19.</span> <span class="toc-text">字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">1.1.19.1.</span> <span class="toc-text">多字节字符集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BD%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6"><span class="toc-number">1.1.19.2.</span> <span class="toc-text">宽字节字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E8%BF%9E%E6%8E%A5%E5%92%8C%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.20.</span> <span class="toc-text">长连接和短连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pragma-pack-%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.21.</span> <span class="toc-text">#pragma pack()用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.22.</span> <span class="toc-text">#和##运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calloc-%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.23.</span> <span class="toc-text">calloc()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E5%BA%94%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93-x2F-%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.1.24.</span> <span class="toc-text">适应多个参数的结构体&#x2F;类初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fd-set"><span class="toc-number">1.1.25.</span> <span class="toc-text">fd_set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0fcntl"><span class="toc-number">1.1.26.</span> <span class="toc-text">函数fcntl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdcall%EF%BC%8C-cdecl%EF%BC%8C-pascal%EF%BC%8C-fastcall%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.27.</span> <span class="toc-text">__stdcall，__cdecl，__pascal，__fastcall的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExitThread-TerminateProcess-ExitProcess"><span class="toc-number">1.1.28.</span> <span class="toc-text">ExitThread TerminateProcess ExitProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E8%BE%93%E5%85%A5"><span class="toc-number">1.1.29.</span> <span class="toc-text">非阻塞输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8CtoString"><span class="toc-number">1.1.30.</span> <span class="toc-text">enum的遍历和toString</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">1.1.31.</span> <span class="toc-text">文件读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93Pipe"><span class="toc-number">1.1.32.</span> <span class="toc-text">管道Pipe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.33.</span> <span class="toc-text">线程与进程问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0char-%E5%8F%82%E6%95%B0%E6%94%B9%E5%8F%98%E6%8C%87%E9%92%88%E5%86%85%E5%AE%B9"><span class="toc-number">1.1.34.</span> <span class="toc-text">函数char*参数改变指针内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.1.35.</span> <span class="toc-text">异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LPCTSTR"><span class="toc-number">1.1.36.</span> <span class="toc-text">LPCTSTR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E6%89%A7%E8%A1%8Cwindows-server%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.37.</span> <span class="toc-text">远程执行windows server中的程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#char-%E5%92%8C-unsigned-char"><span class="toc-number">1.1.38.</span> <span class="toc-text">char 和 unsigned char</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8char-%E8%BD%AC%E6%88%90int%E5%9E%8B"><span class="toc-number">1.1.39.</span> <span class="toc-text">关于使用char 转成int型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%82%E6%88%96%E6%B3%95%EF%BC%8C%E8%8C%83%E5%9B%B4%E4%B8%8Eint%E5%9E%8B%E5%90%8C"><span class="toc-number">1.1.39.1.</span> <span class="toc-text">1. 异或法，范围与int型同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-memcpy%E8%BF%9B%E8%A1%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E5%88%B6"><span class="toc-number">1.1.39.2.</span> <span class="toc-text">2. memcpy进行空间复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8ASCII%E7%A0%81%EF%BC%8C%E8%8C%83%E5%9B%B49999"><span class="toc-number">1.1.39.3.</span> <span class="toc-text">3. 存储ASCII码，范围9999</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.1.40.</span> <span class="toc-text">三目运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-cout%E5%88%A9%E7%94%A8%E6%8E%A7%E5%88%B6%E7%AC%A6dec%E3%80%81hex%E5%92%8Coct%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%8D%81%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%92%8C%E5%85%AB%E8%BF%9B%E5%88%B6%E6%98%BE%E7%A4%BA%E6%95%B4%E6%95%B0"><span class="toc-number">1.1.41.</span> <span class="toc-text">C++ cout利用控制符dec、hex和oct，分别输出十进制、十六进制和八进制显示整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#strcat"><span class="toc-number">1.1.42.</span> <span class="toc-text">strcat()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#int64"><span class="toc-number">1.1.43.</span> <span class="toc-text">int64</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E4%B8%AD%E7%9A%84c-str-%E7%94%A8%E6%B3%95"><span class="toc-number">1.1.44.</span> <span class="toc-text">c++中的c_str()用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atof"><span class="toc-number">1.1.45.</span> <span class="toc-text">atof()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#itoa"><span class="toc-number">1.1.46.</span> <span class="toc-text">itoa()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%AD%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.1.47.</span> <span class="toc-text">获取指针所指向的地址中的空间大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator"><span class="toc-number">1.1.48.</span> <span class="toc-text">迭代器 iterator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assert-%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.49.</span> <span class="toc-text">assert()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ispunct"><span class="toc-number">1.1.50.</span> <span class="toc-text">ispunct()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#assign"><span class="toc-number">1.1.51.</span> <span class="toc-text">assign()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-c-str-%E5%92%8Cdata"><span class="toc-number">1.1.52.</span> <span class="toc-text">string c_str()和data()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#menset"><span class="toc-number">1.1.53.</span> <span class="toc-text">menset()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stdcall"><span class="toc-number">1.1.54.</span> <span class="toc-text">__stdcall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%9B%BA%E5%AE%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0int-test-void-x"><span class="toc-number">1.1.55.</span> <span class="toc-text">不固定函数参数int test(void* x,...)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-x2F-C-%E4%B8%ADnear%E5%92%8Cfar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.56.</span> <span class="toc-text">C&#x2F;C++中near和far的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96"><span class="toc-number">1.1.57.</span> <span class="toc-text">时间获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gettimeofday-%E5%BE%AE%E7%A7%92-1e-6-s-%E9%87%8F%E7%BA%A7"><span class="toc-number">1.1.57.1.</span> <span class="toc-text">gettimeofday | 微秒(1e-6 s)量级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GetTickCount-%E6%AF%AB%E7%A7%92"><span class="toc-number">1.1.57.2.</span> <span class="toc-text">GetTickCount() | 毫秒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timeb%E7%B1%BB-%E6%AF%AB%E7%A7%92ms"><span class="toc-number">1.1.57.3.</span> <span class="toc-text">timeb类 | 毫秒ms</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%80%A7%E8%83%BD%E8%AE%A1%E6%95%B0%E5%99%A8%E8%AE%A1%E7%AE%97-QueryPerformanceCounter-%E5%BE%AE%E7%A7%92us"><span class="toc-number">1.1.57.4.</span> <span class="toc-text">基于性能计数器计算 QueryPerformanceCounter() | 微秒us</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#time-t-%E5%BE%97%E5%88%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%9A%84%E6%97%B6%E9%97%B4-%E6%AF%AB%E7%A7%92"><span class="toc-number">1.1.57.5.</span> <span class="toc-text">time_t 得到格式化的时间 | 毫秒</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timeval-%E5%BE%AE%E7%A7%92"><span class="toc-number">1.1.57.6.</span> <span class="toc-text">timeval | 微秒</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C-gt-%E2%80%9D-%E5%92%8C-%E2%80%9C-%E2%80%9D-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.58.</span> <span class="toc-text">“-&gt;” 和 “.” 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Subordinates-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.59.</span> <span class="toc-text">Subordinates 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast%E5%92%8Cstatic-cast"><span class="toc-number">1.1.60.</span> <span class="toc-text">dynamic_cast和static_cast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nullptr%E5%92%8CNULL"><span class="toc-number">1.1.61.</span> <span class="toc-text">nullptr和NULL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%B4%A2%E5%BC%95"><span class="toc-number">1.2.</span> <span class="toc-text">问题索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cc1-error-x2F-usr-x2F-local-x2F-include-x2F-x86-64-linux-gnu-Permission-denied"><span class="toc-number">1.2.1.</span> <span class="toc-text">cc1: error: &#x2F;usr&#x2F;local&#x2F;include&#x2F;x86_64-linux-gnu: Permission denied</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAP-CORRUPTION-DETECTED-after-Normal-block-1375-at-0x0000000000853200-CRT-detected-that-the-application-wrote-to-memory-after-end-of-heap-buffer"><span class="toc-number">1.2.2.</span> <span class="toc-text">HEAP CORRUPTION DETECTED: after Normal block (#1375) at 0x0000000000853200. CRT detected that the application wrote to memory after end of heap buffer.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CRT-detected-that-the-application-wrote-to-memory-after-end-of-heap-buffer"><span class="toc-number">1.2.3.</span> <span class="toc-text">CRT detected that the application wrote to memory after end of heap buffer.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#debug-assertion-failed-expression-stream-valid"><span class="toc-number">1.2.4.</span> <span class="toc-text">debug assertion failed expression:stream.valid()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#error-C4996%E2%80%98fopen%E2%80%99-This-function-or-variable-may-be-unsafe-Consider-using-fopen-s-instead-To-disable-deprecation-use-CRT-SECURE-NO-WARNINGS-See-online-help-for-details"><span class="toc-number">1.2.5.</span> <span class="toc-text">error C4996	‘fopen’: This function or variable may be unsafe. Consider using fopen_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%80%BC%E4%B8%8D%E8%83%BD%E7%94%A8%E4%BA%8E%E5%88%9D%E5%A7%8B%E5%8C%96-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AE%9E%E4%BD%93"><span class="toc-number">1.2.6.</span> <span class="toc-text">C++ 类型的值不能用于初始化 类型的实体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MTD"><span class="toc-number">1.2.7.</span> <span class="toc-text">MTD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.8.</span> <span class="toc-text">包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.9.</span> <span class="toc-text">链接问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC%E5%BF%85%E9%A1%BB%E6%98%AF%E5%B7%A6%E5%80%BC"><span class="toc-number">1.2.10.</span> <span class="toc-text">非常量引用的初始值必须是左值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A7%E4%B8%8D%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B8%AD%E6%82%A8%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%8F%8D%E6%B1%87%E7%BC%96%E7%AA%97%E5%8F%A3-%E6%A0%88%E5%92%8C%E5%B8%A7%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.11.</span> <span class="toc-text">帧不在模块中您可以在反汇编窗口_栈和帧指针使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dll%E6%96%87%E4%BB%B6%E5%92%8Clib%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.12.</span> <span class="toc-text">dll文件和lib文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%BA%93%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.13.</span> <span class="toc-text">STL库函数返回值问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#winsock-h%E5%92%8Cwinsock2-h%E9%87%8D%E5%AE%9A%E4%B9%89%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.14.</span> <span class="toc-text">winsock.h和winsock2.h重定义问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E9%87%8D%E5%A4%8D%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.15.</span> <span class="toc-text">关于变量重复定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0xC0000374-%E5%A0%86%E5%B7%B2%E6%8D%9F%E5%9D%8F"><span class="toc-number">1.2.16.</span> <span class="toc-text">0xC0000374: 堆已损坏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B80xcccccccc%E3%80%810xcdcdcdcd%E4%B8%8E%E6%8C%87%E9%92%88%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.17.</span> <span class="toc-text">异常0xcccccccc、0xcdcdcdcd与指针初始化问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90%E7%9A%84%E5%A4%96%E9%83%A8%E7%AC%A6%E5%8F%B7%E5%8F%91%E7%94%9F%E5%9C%A8%E5%93%AA%E4%B8%80%E4%B8%AA%E6%97%B6%E6%9C%9F"><span class="toc-number">1.2.18.</span> <span class="toc-text">无法解析的外部符号发生在哪一个时期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92559631349317830736831783200707727132248687965119994463780864-000000"><span class="toc-number">1.2.19.</span> <span class="toc-text">-92559631349317830736831783200707727132248687965119994463780864.000000</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%8C%85%E9%94%99%E8%AF%AF-%E5%85%B7%E4%BD%93%E6%98%AF%E4%B8%A4%E8%80%85%E5%8F%91%E7%94%9F%E7%9A%84%E5%86%B2%E7%AA%81"><span class="toc-number">1.2.20.</span> <span class="toc-text">网络包错误 具体是两者发生的冲突</span></a></li></ol></li></ol></li></ol>
            </div>
        
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 91
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
        
            
            
            <div class="archive-year"> 2025 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span>
            <a class="archive-post-title" href="/2025/03/17/unix%E5%86%85%E6%A0%B8%E6%80%81/">UNIX 内核态</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2024 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/23</span>
            <a class="archive-post-title" href="/2024/12/23/OpenEuler/">OpenEuler</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/2024/11/10/%E5%BC%B1%E7%BD%91%E6%9D%A1%E4%BB%B6%E6%A8%A1%E6%8B%9F/">弱网条件模拟</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/05</span>
            <a class="archive-post-title" href="/2024/07/05/%E5%85%AC%E7%BD%91ip%E6%98%A0%E5%B0%84/">公网ip映射问题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span>
            <a class="archive-post-title" href="/2024/06/18/hibernate/">Hibernate</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span>
            <a class="archive-post-title" href="/2024/04/17/%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E5%85%B1%E4%BA%ABWLAN/">局域网内共享WLAN</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2023 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/12</span>
            <a class="archive-post-title" href="/2023/04/12/VScode_debug/">VScode Debuge</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/27</span>
            <a class="archive-post-title" href="/2023/03/27/big_data&flow_calculation/">大数据和流式计算</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/10</span>
            <a class="archive-post-title" href="/2023/03/10/docker_use/">Docker Used Node</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/02</span>
            <a class="archive-post-title" href="/2023/03/02/skiplist_analyze/">Skiplist Analyze</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2022 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/07</span>
            <a class="archive-post-title" href="/2022/11/07/Mysql_Read_record/">Mysql_Read_record</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span>
            <a class="archive-post-title" href="/2022/11/03/Berkeley_Read_record/">Berkeley_Read_record</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span>
            <a class="archive-post-title" href="/2022/09/28/UNIX%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">UNIX系统使用笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/18</span>
            <a class="archive-post-title" href="/2022/08/18/Python%E5%92%8CCpp%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/">Python和Cpp混合编程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/10</span>
            <a class="archive-post-title" href="/2022/08/10/TDengine%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/">TDengine技术分析</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/10</span>
            <a class="archive-post-title" href="/2022/03/10/%E5%AD%A6%E4%B9%A0%E6%96%B9%E5%BC%8F%E7%AD%96%E5%88%92%E6%96%B9%E6%A1%88/">学习方式策划方案</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2021 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">11/17</span>
            <a class="archive-post-title" href="/2021/11/17/QT%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/">QT学习札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/25</span>
            <a class="archive-post-title" href="/2021/08/25/Lib%E5%92%8CDLL%E8%AF%A6%E8%A7%A3/">Lib和DLL详解</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/11</span>
            <a class="archive-post-title" href="/2021/08/11/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/">算法学习笔记02</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span>
            <a class="archive-post-title" href="/2021/07/24/%E5%8C%97%E4%BA%AC%E9%A3%9F%E5%BA%97%E6%94%B6%E5%BD%95/">北京食店收录</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/08</span>
            <a class="archive-post-title" href="/2021/07/08/Cmake%E5%92%8Cbison/">Cmake和bison</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/17</span>
            <a class="archive-post-title" href="/2021/06/17/mysql%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Mysql源码以及Mysql ODBC源码分析</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2021/06/04/%E5%AD%97%E4%BD%93%E7%89%88%E6%9D%83%E9%97%AE%E9%A2%98/">字体版权问题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2021/06/04/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/">EKF，UKF，CKF，PF非线性滤波算法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/28</span>
            <a class="archive-post-title" href="/2021/05/28/DB_%E6%9C%8D%E5%8A%A1%E5%99%A8_%E6%A1%A5%E9%80%BB%E8%BE%91/">DB 服务器 桥逻辑</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/25</span>
            <a class="archive-post-title" href="/2021/05/25/SQLite/">SQLite</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/18</span>
            <a class="archive-post-title" href="/2021/05/18/Cppwindows%E6%9C%8D%E5%8A%A1/">C/C++windows服务</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/13</span>
            <a class="archive-post-title" href="/2021/05/13/ODBC%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/">ODBC连接数据库</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/06</span>
            <a class="archive-post-title" href="/2021/05/06/ODBC%E7%90%86%E8%AE%BA/">ODBC理论</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/06</span>
            <a class="archive-post-title" href="/2021/05/06/ODBC%E7%BC%96%E7%A8%8B/">ODBC编程</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span>
            <a class="archive-post-title" href="/2021/05/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/">智能指针</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span>
            <a class="archive-post-title" href="/2021/04/28/B%E6%A0%91%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/">B树学习札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/27</span>
            <a class="archive-post-title" href="/2021/04/27/Rust%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E6%89%8E%E8%AE%B0/">Rust编程学习扎记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span>
            <a class="archive-post-title" href="/2021/04/16/C++%E5%9F%BA%E6%9C%AC%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%80%9D%E8%B7%AF/">C++基本项目开发思路</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span>
            <a class="archive-post-title" href="/2021/04/13/TCP%E4%B8%8EUDP%E5%AE%9E%E7%8E%B0/">TCP与UDP实现</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/11</span>
            <a class="archive-post-title" href="/2021/04/11/%E5%BC%80%E5%8F%91%E8%80%85%E6%89%8B%E5%86%8C/">开发者手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span>
            <a class="archive-post-title" href="/2021/04/10/CRC%E5%BE%AA%E7%8E%AF%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C/">CRC循环冗余校验</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span>
            <a class="archive-post-title" href="/2021/04/10/CCpp%E9%97%AE%E9%A2%98%E6%94%B6%E5%BD%95%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">C/C++问题收录与知识积累</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/08</span>
            <a class="archive-post-title" href="/2021/03/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/">数据库理论系统学习手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/08</span>
            <a class="archive-post-title" href="/2021/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/">计算机网络具体实现</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">03/05</span>
            <a class="archive-post-title" href="/2021/03/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%A5%E9%97%A8%E8%B7%AF%E7%BA%BF/">计算机入门路线(应用篇)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/06</span>
            <a class="archive-post-title" href="/2021/02/06/Nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Nodejs学习笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2021/02/03/Apache%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/">Apache系统管理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2021/02/03/Linux%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86%E4%B8%8E%E5%BB%BA%E5%BA%93/">Linux下数据库管理与建库</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2021/02/03/Linux%E5%91%BD%E4%BB%A4%E6%80%BB%E9%9B%86%E4%B8%8E%E7%B3%BB%E7%BB%9F/">Linux命令总集与系统</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">02/03</span>
            <a class="archive-post-title" href="/2021/02/03/%E7%BC%96%E7%A0%81%E6%80%BB%E7%BB%93/">编码总集</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/21</span>
            <a class="archive-post-title" href="/2021/01/21/%E8%BD%AF%E4%BB%B6%E6%80%BB%E9%9B%86/">软件总集以及网站</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/20</span>
            <a class="archive-post-title" href="/2021/01/20/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">英语学习笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/Ps%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/">Ps学习札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/git_use_page/">git 及 github 使用手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/php%E8%BF%9B%E9%98%B6%E6%89%8B%E5%86%8C/">php进阶手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93/">工具总结</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/05</span>
            <a class="archive-post-title" href="/2021/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/">数据结构具体实现</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/CCpp%E8%BF%9B%E9%98%B6/">C/C++进阶</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/Linux%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">`Linux`编程笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/String%E5%87%BD%E6%95%B0/">C/C++ String函数</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/VS%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/">VS C++开发使用笔记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/%E5%90%84%E8%BD%AF%E4%BB%B6%E5%8F%8Awindows%E6%93%8D%E4%BD%9C%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E9%9B%86/">各软件及windows操作快捷键总集</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">01/02</span>
            <a class="archive-post-title" href="/2021/01/02/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/">算法学习笔记01</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2018 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span>
            <a class="archive-post-title" href="/2018/12/06/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">线程与进程管理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span>
            <a class="archive-post-title" href="/2018/10/10/Linux%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8oo/">Linux网络应用</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/30</span>
            <a class="archive-post-title" href="/2018/09/30/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5oo/">宽字节注入</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span>
            <a class="archive-post-title" href="/2018/09/13/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Foo/">正则表达式</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span>
            <a class="archive-post-title" href="/2018/09/05/%E9%AB%98%E9%A2%91%E8%AF%8D%E6%B1%87%E8%A1%A8oo/">高频词汇表</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/30</span>
            <a class="archive-post-title" href="/2018/08/30/%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%E4%B9%8B%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E8%AE%B0oo/">系统管理之重装系统记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/29</span>
            <a class="archive-post-title" href="/2018/08/29/%E6%89%93%E5%8D%B0%E6%9C%BA%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8Coo/">打印机问题及使用方法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/20</span>
            <a class="archive-post-title" href="/2018/08/20/%E6%96%87%E4%BB%B6%E5%A4%B4%E6%96%87%E4%BB%B6%E5%B0%BE%E6%80%BB%E7%BB%93oo/">文件类型以及分析手册</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">08/11</span>
            <a class="archive-post-title" href="/2018/08/11/Linux%E4%B8%8B%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83(lamp%E5%92%8Cshadowsocks%E3%80%81lnmp)oo/">Linux下配置服务器环境(lamp和shadowsocks、lnmp)</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span>
            <a class="archive-post-title" href="/2018/07/25/AntDesignPro/">RESTful架构与Ant Design Pro开发项目</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span>
            <a class="archive-post-title" href="/2018/07/25/wiki%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0oo/">Wiki搭建</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span>
            <a class="archive-post-title" href="/2018/07/15/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%B6%89%E7%8C%8Eoo/">大数据涉猎</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/07</span>
            <a class="archive-post-title" href="/2018/07/07/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86oo/">通信原理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span>
            <a class="archive-post-title" href="/2018/06/18/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BAoo/">算法导论</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span>
            <a class="archive-post-title" href="/2018/06/18/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/">编译原理之预测分析器的设计与实现</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span>
            <a class="archive-post-title" href="/2018/06/18/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E6%86%A9/">项目小憩</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/11</span>
            <a class="archive-post-title" href="/2018/06/11/SQL%E8%AF%AD%E5%8F%A5%E6%9C%AD%E8%AE%B0oo/">SQL语句札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/11</span>
            <a class="archive-post-title" href="/2018/06/11/%E5%9F%BA%E4%BA%8EMIPS%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%8432%E4%BD%8D%E4%BA%94%E7%BA%A7%E6%B5%81%E6%B0%B4%E7%BA%BFCPU%E8%AE%BE%E8%AE%A1oo/">基于MIPS指令集的32位五级流水线CPU设计</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2018/06/04/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E6%89%AB%E6%8F%8Foo/">攻防安全之扫描</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">06/04</span>
            <a class="archive-post-title" href="/2018/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86oo/">计算机组成原理</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/25</span>
            <a class="archive-post-title" href="/2018/05/25/%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE%E5%BA%93%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/">创新创业项目库管理系统</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/23</span>
            <a class="archive-post-title" href="/2018/05/23/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90oo/">编译原理之语法分析程序</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/20</span>
            <a class="archive-post-title" href="/2018/05/20/WebCollector%E7%88%AC%E8%99%AB%E4%B8%8EHbase/">WebCollector爬虫与Hbase</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/18</span>
            <a class="archive-post-title" href="/2018/05/18/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86oo/">加密解密的艺术</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/15</span>
            <a class="archive-post-title" href="/2018/05/15/Linux%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEoo/">配置Linux环境</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span>
            <a class="archive-post-title" href="/2018/05/12/SQL%E6%B3%A8%E5%85%A5/">SQL注入札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span>
            <a class="archive-post-title" href="/2018/05/12/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98oo/">数据库中文乱码问题</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/12</span>
            <a class="archive-post-title" href="/2018/05/12/%E7%BD%91%E9%A1%B5%E7%8A%B6%E6%80%81%E6%89%8B%E5%86%8C/">网页状态提示说明</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/10</span>
            <a class="archive-post-title" href="/2018/05/10/hexo%E6%9C%AD%E8%AE%B0/">hexo 札记</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">05/08</span>
            <a class="archive-post-title" href="/2018/05/08/DOS%E5%91%BD%E4%BB%A4%E6%89%AB%E6%8F%8F%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3/">DOS命令扫描指定端口并查看端口号</a>
        </li>
    
        
            
            
                
                </ul>
            
            <div class="archive-year"> 2017 </div>
            <ul class="year-list">
            
        
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span>
            <a class="archive-post-title" href="/2017/10/18/Markdown%E8%AF%AD%E6%B3%95%E8%AF%B4%E6%98%8Eoo/">markdown语法</a>
        </li>
    
        
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span>
            <a class="archive-post-title" href="/2017/07/25/JS%E8%BF%9B%E9%98%B6oo/">JS进阶</a>
        </li>
    
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
        
            <span class="sidebar-tag-name" data-tags="数据库">
                <span class="iconfont-archer">&#xe606;</span>
                数据库
            </span>
        
            <span class="sidebar-tag-name" data-tags="JAVA">
                <span class="iconfont-archer">&#xe606;</span>
                JAVA
            </span>
        
            <span class="sidebar-tag-name" data-tags="python">
                <span class="iconfont-archer">&#xe606;</span>
                python
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- RTthread">
                <span class="iconfont-archer">&#xe606;</span>
                -- RTthread
            </span>
        
            <span class="sidebar-tag-name" data-tags="Linux">
                <span class="iconfont-archer">&#xe606;</span>
                Linux
            </span>
        
            <span class="sidebar-tag-name" data-tags="unix">
                <span class="iconfont-archer">&#xe606;</span>
                unix
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- C/C++">
                <span class="iconfont-archer">&#xe606;</span>
                -- C/C++
            </span>
        
            <span class="sidebar-tag-name" data-tags="RESTful">
                <span class="iconfont-archer">&#xe606;</span>
                RESTful
            </span>
        
            <span class="sidebar-tag-name" data-tags="Ant Design Pro">
                <span class="iconfont-archer">&#xe606;</span>
                Ant Design Pro
            </span>
        
            <span class="sidebar-tag-name" data-tags="React">
                <span class="iconfont-archer">&#xe606;</span>
                React
            </span>
        
            <span class="sidebar-tag-name" data-tags="前后端分离">
                <span class="iconfont-archer">&#xe606;</span>
                前后端分离
            </span>
        
            <span class="sidebar-tag-name" data-tags="apache">
                <span class="iconfont-archer">&#xe606;</span>
                apache
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- Berkeley">
                <span class="iconfont-archer">&#xe606;</span>
                -- Berkeley
            </span>
        
            <span class="sidebar-tag-name" data-tags="C/C++">
                <span class="iconfont-archer">&#xe606;</span>
                C/C++
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- work -- cmake">
                <span class="iconfont-archer">&#xe606;</span>
                -- work -- cmake
            </span>
        
            <span class="sidebar-tag-name" data-tags="JS">
                <span class="iconfont-archer">&#xe606;</span>
                JS
            </span>
        
            <span class="sidebar-tag-name" data-tags="mysql">
                <span class="iconfont-archer">&#xe606;</span>
                mysql
            </span>
        
            <span class="sidebar-tag-name" data-tags="SQL">
                <span class="iconfont-archer">&#xe606;</span>
                SQL
            </span>
        
            <span class="sidebar-tag-name" data-tags="lamp">
                <span class="iconfont-archer">&#xe606;</span>
                lamp
            </span>
        
            <span class="sidebar-tag-name" data-tags="lnmp">
                <span class="iconfont-archer">&#xe606;</span>
                lnmp
            </span>
        
            <span class="sidebar-tag-name" data-tags="Markdown">
                <span class="iconfont-archer">&#xe606;</span>
                Markdown
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- Mysql">
                <span class="iconfont-archer">&#xe606;</span>
                -- Mysql
            </span>
        
            <span class="sidebar-tag-name" data-tags="hexo">
                <span class="iconfont-archer">&#xe606;</span>
                hexo
            </span>
        
            <span class="sidebar-tag-name" data-tags="git">
                <span class="iconfont-archer">&#xe606;</span>
                git
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- C/C++ -- ODBC">
                <span class="iconfont-archer">&#xe606;</span>
                -- C/C++ -- ODBC
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- C/C++ -- QT">
                <span class="iconfont-archer">&#xe606;</span>
                -- C/C++ -- QT
            </span>
        
            <span class="sidebar-tag-name" data-tags="rust">
                <span class="iconfont-archer">&#xe606;</span>
                rust
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- work">
                <span class="iconfont-archer">&#xe606;</span>
                -- work
            </span>
        
            <span class="sidebar-tag-name" data-tags="Socket网络编程">
                <span class="iconfont-archer">&#xe606;</span>
                Socket网络编程
            </span>
        
            <span class="sidebar-tag-name" data-tags="linux">
                <span class="iconfont-archer">&#xe606;</span>
                linux
            </span>
        
            <span class="sidebar-tag-name" data-tags="project">
                <span class="iconfont-archer">&#xe606;</span>
                project
            </span>
        
            <span class="sidebar-tag-name" data-tags="大数据">
                <span class="iconfont-archer">&#xe606;</span>
                大数据
            </span>
        
            <span class="sidebar-tag-name" data-tags="ocker">
                <span class="iconfont-archer">&#xe606;</span>
                ocker
            </span>
        
            <span class="sidebar-tag-name" data-tags="java">
                <span class="iconfont-archer">&#xe606;</span>
                java
            </span>
        
            <span class="sidebar-tag-name" data-tags="algorithm">
                <span class="iconfont-archer">&#xe606;</span>
                algorithm
            </span>
        
            <span class="sidebar-tag-name" data-tags="wiki">
                <span class="iconfont-archer">&#xe606;</span>
                wiki
            </span>
        
            <span class="sidebar-tag-name" data-tags="信息安全">
                <span class="iconfont-archer">&#xe606;</span>
                信息安全
            </span>
        
            <span class="sidebar-tag-name" data-tags="网络运维">
                <span class="iconfont-archer">&#xe606;</span>
                网络运维
            </span>
        
            <span class="sidebar-tag-name" data-tags="参考文档">
                <span class="iconfont-archer">&#xe606;</span>
                参考文档
            </span>
        
            <span class="sidebar-tag-name" data-tags="Hadoop">
                <span class="iconfont-archer">&#xe606;</span>
                Hadoop
            </span>
        
            <span class="sidebar-tag-name" data-tags="免密登入">
                <span class="iconfont-archer">&#xe606;</span>
                免密登入
            </span>
        
            <span class="sidebar-tag-name" data-tags="--">
                <span class="iconfont-archer">&#xe606;</span>
                --
            </span>
        
            <span class="sidebar-tag-name" data-tags="CPU">
                <span class="iconfont-archer">&#xe606;</span>
                CPU
            </span>
        
            <span class="sidebar-tag-name" data-tags="Mysql">
                <span class="iconfont-archer">&#xe606;</span>
                Mysql
            </span>
        
            <span class="sidebar-tag-name" data-tags="文件类型">
                <span class="iconfont-archer">&#xe606;</span>
                文件类型
            </span>
        
            <span class="sidebar-tag-name" data-tags="算法">
                <span class="iconfont-archer">&#xe606;</span>
                算法
            </span>
        
            <span class="sidebar-tag-name" data-tags="编译原理">
                <span class="iconfont-archer">&#xe606;</span>
                编译原理
            </span>
        
            <span class="sidebar-tag-name" data-tags="计划">
                <span class="iconfont-archer">&#xe606;</span>
                计划
            </span>
        
            <span class="sidebar-tag-name" data-tags="-- English">
                <span class="iconfont-archer">&#xe606;</span>
                -- English
            </span>
        
            <span class="sidebar-tag-name" data-tags="计算机组成原理">
                <span class="iconfont-archer">&#xe606;</span>
                计算机组成原理
            </span>
        
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "http://itheds.github.io",
        root: siteMetaRoot,
        author: "iTheds"
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->


        <!-- main func -->
        <script src="/scripts/main.js?v=20211217"></script>
        <!-- dark mode -->
        <script src="/scripts/dark.js?v=20211217"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" defer></script>
        <!-- algolia -->
        
        <!-- busuanzi -->
        
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        
        <!-- CNZZ -->
        
        <!-- async load share.js -->
        
            <script src="/scripts/share.js?v=20211217" async></script>
        
        <!-- mermaid -->
        
    </body>
</html>
